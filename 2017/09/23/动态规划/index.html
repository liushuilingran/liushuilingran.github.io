<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>动态规划专题 - MCFON</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MCFON"><meta name="msapplication-TileImage" content="/images/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MCFON"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="DP 问题的一般思路 DP 定义 ——有时 DP 的更新很难严格遵循定义，需要额外变量保存全局最优结果 初始化 ——初始值可以通过一个简单的特例来确定 递推公式 + 边界条件 DP 优化 （可选）  Reference 常见的动态规划问题分析与求解 - 五岳 - 博客园 什么是动态规划？动态规划的意义是什么？ - 知乎"><meta property="og:type" content="blog"><meta property="og:title" content="动态规划专题"><meta property="og:url" content="https://huzhiliang.com/2017/09/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><meta property="og:site_name" content="MCFON"><meta property="og:description" content="DP 问题的一般思路 DP 定义 ——有时 DP 的更新很难严格遵循定义，需要额外变量保存全局最优结果 初始化 ——初始值可以通过一个简单的特例来确定 递推公式 + 边界条件 DP 优化 （可选）  Reference 常见的动态规划问题分析与求解 - 五岳 - 博客园 什么是动态规划？动态规划的意义是什么？ - 知乎"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g78kb88crbj305004ygls.jpg"><meta property="og:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g78kgyjxv2j30il0f5jvn.jpg"><meta property="article:published_time" content="2017-09-23T11:50:53.000Z"><meta property="article:modified_time" content="2019-11-17T22:30:18.482Z"><meta property="article:author" content="ฅ´ω`ฅ"><meta property="article:tag" content="动态规划"><meta property="article:tag" content="专题"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://tva1.sinaimg.cn/large/006y8mN6ly1g78kb88crbj305004ygls.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://huzhiliang.com/2017/09/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},"headline":"MCFON","image":["https://tva1.sinaimg.cn/large/006y8mN6ly1g78kb88crbj305004ygls.jpg","https://tva1.sinaimg.cn/large/006y8mN6ly1g78kgyjxv2j30il0f5jvn.jpg"],"datePublished":"2017-09-23T11:50:53.000Z","dateModified":"2019-11-17T22:30:18.482Z","author":{"@type":"Person","name":"ฅ´ω`ฅ"},"description":"DP 问题的一般思路 DP 定义 ——有时 DP 的更新很难严格遵循定义，需要额外变量保存全局最优结果 初始化 ——初始值可以通过一个简单的特例来确定 递推公式 + 边界条件 DP 优化 （可选）  Reference 常见的动态规划问题分析与求解 - 五岳 - 博客园 什么是动态规划？动态规划的意义是什么？ - 知乎"}</script><link rel="canonical" href="https://huzhiliang.com/2017/09/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/" alt="MCFON" height="28"><img class="logo-img-dark" src="/" alt="MCFON" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2017-09-23T11:50:53.000Z" title="2017-09-23T11:50:53.000Z">2017-09-23</time>发表</span><span class="level-item"><time dateTime="2019-11-17T22:30:18.482Z" title="2019-11-17T22:30:18.482Z">2019-11-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a></span><span class="level-item">1 小时读完 (大约7593个字)</span><span class="level-item leancloud_visitors" id="/2017/09/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" data-flag-title="动态规划专题"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="twikoo_visitors"><i class="fa fa-spinner fa-spin"></i></span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">动态规划专题</h1><div class="content"><h2 id="DP-问题的一般思路"><a href="#DP-问题的一般思路" class="headerlink" title="DP 问题的一般思路"></a>DP 问题的一般思路</h2><ul>
<li><strong>DP 定义</strong> ——有时 DP 的更新很难严格遵循定义，需要额外变量保存全局最优结果</li>
<li><strong>初始化</strong> ——初始值可以通过一个简单的特例来确定</li>
<li><strong>递推公式</strong> + <strong>边界条件</strong></li>
<li><strong>DP 优化</strong> （可选）</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuyuegb2312/p/3281264.html">常见的动态规划问题分析与求解 - 五岳</a> - 博客园</li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23995189">什么是动态规划？动态规划的意义是什么？</a> - 知乎 <a id="more"></a>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2></li>
</ul>
<h3 id="【注】关于“恰好装满”"><a href="#【注】关于“恰好装满”" class="headerlink" title="【注】关于“恰好装满”"></a>【注】关于“恰好装满”</h3><ul>
<li><strong>如果要求恰好装满背包</strong>，可以在初始化时将 <code>dp[0] / dp[i][0]</code> 初始化 <code>0</code>，其他初始化为 <code>-INF</code>。这样即可保证最终得到的 <code>dp[N] / dp[N][M]</code> 是一种恰好装满背包的解；</li>
<li><strong>如果不要求恰好装满</strong>，则全部初始化为 <code>0</code> 即可。</li>
<li>可以这样理解：初始化的 dp 数组实际上就是在没有任何物品可以放入背包时的合法状态。<ul>
<li>如果要求背包恰好装满，那么此时只有<strong>容量为 0</strong> 的背包可能被<strong>价值为 0</strong> 的物品“<strong>恰好装满</strong>”，其它容量的背包均<strong>没有合法的解</strong>，属于未定义的状态，它们的值就都应该是 <code>-INF</code> 。</li>
<li>如果背包并非必须被装满，那么任何容量的背包都有一个合法解，即“什么都不装”，这个解的价值为0，所以初始时状态的值也全部为 0 。</li>
</ul>
</li>
</ul>
<h3 id="01-背包"><a href="#01-背包" class="headerlink" title="01 背包"></a>01 背包</h3><blockquote>
<p><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=2602">HDOJ - 2602</a></p>
</blockquote>
<p><strong>问题描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">有 n 个重量个价值分别为 w_i, v_i 的物品。</span><br><span class="line">从这些物品中选出总重量不超过 W 的物品，使其总价值最大。</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">1                &#x2F;&#x2F; 用例数</span><br><span class="line">5 10             &#x2F;&#x2F; 物品数 背包容量 N &lt;&#x3D; 1000 , V &lt;&#x3D; 1000</span><br><span class="line">1 2 3 4 5</span><br><span class="line">5 4 3 2 1</span><br><span class="line"></span><br><span class="line">14</span><br></pre></td></tr></table></figure>
<h4 id="二维-DP（无优化）"><a href="#二维-DP（无优化）" class="headerlink" title="二维 DP（无优化）"></a>二维 DP（无优化）</h4><ul>
<li><p><strong>定义</strong>：<code>dp[i][j] := 从前 i 个物品中选取总重量不超过 j 的物品时总价值的最大值</code></p>
<blockquote>
<p><code>i</code> 从 1 开始计，包括第 <code>i</code> 个物品</p>
</blockquote>
</li>
<li><p><strong>初始化</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[0][j] &#x3D; 0</span><br></pre></td></tr></table></figure></li>
<li><p><strong>状态转移</strong></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; dp[i-1][j]            if j &lt; w[i] （当前剩余容量不够放下第 i 个物品）</span><br><span class="line">         &#x3D; max&#123;                  else （取以下两种情况的最大值）</span><br><span class="line">                dp[i-1][j],             &#x2F;&#x2F; 不拿第 i 个物品</span><br><span class="line">                dp[i-1][j-w[i]] + w[j]  &#x2F;&#x2F; 拿第 i 个物品</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HDOJ 地址：http://acm.hdu.edu.cn/showproblem.php?pid=2602</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> V, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(V + <span class="number">1</span>, <span class="number">0</span>));  <span class="comment">// 不要求装满，初始化为 0 即可</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;  <span class="comment">// 可能存在重量为 0，但有价值的物品</span></span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; j)               <span class="comment">// 如果当前物品的重量大于剩余容量</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;      <span class="comment">// 用例数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> N, V;                   <span class="comment">// N: 物品数量；V: 背包容量</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;V);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;    <span class="comment">// 保存每个物品的价值</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">w</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;    <span class="comment">// 保存每个物品的重量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = solve(N, V, v, w);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二维-DP（滚动数组）"><a href="#二维-DP（滚动数组）" class="headerlink" title="二维 DP（滚动数组）"></a>二维 DP（滚动数组）</h4></li>
<li><p>在上述递推式中，<code>dp[i+1]</code> 的计算实际只用到了 <code>dp[i+1]</code> 和 <code>dp[i]</code>；</p>
</li>
<li><p>因此可以结合<strong>奇偶</strong>，通过两个数组滚动使用来实现重复利用。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HDOJ 地址：http://acm.hdu.edu.cn/showproblem.php?pid=2602</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> V, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//vector&lt;vector&lt;int&gt; &gt; dp(N + 1, vector&lt;int&gt;(V + 1, 0));  // 不要求装满，初始化为 0 即可</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(V + <span class="number">1</span>, <span class="number">0</span>));  <span class="comment">// N+1 -&gt; 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;  <span class="comment">// 可能存在重量为 0，但有价值的物品</span></span><br><span class="line">            <span class="keyword">if</span> (w[i] &gt; j)               <span class="comment">// 如果当前物品的重量大于剩余容量</span></span><br><span class="line">                dp[i &amp; <span class="number">1</span>][j] = dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i &amp; <span class="number">1</span>][j] = max(dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j], dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N &amp; <span class="number">1</span>][V];  <span class="comment">// 这里别忘了 N &amp; 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 函数略</span></span><br></pre></td></tr></table></figure>
<h4 id="一维-DP"><a href="#一维-DP" class="headerlink" title="一维 DP"></a>一维 DP</h4><ul>
<li><strong>定义</strong>：<code>dp[j] := 重量不超过 j 公斤的最大价值</code></li>
<li><strong>递推公式</strong>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] &#x3D; max&#123;dp[j], dp[j-w[i]] + v[i]&#125;     若 j &gt; w[i]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HDOJ 地址：http://acm.hdu.edu.cn/showproblem.php?pid=2602</span></span><br><span class="line"><span class="comment">// 一维 DP（滚动数组）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> V, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; w)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(V + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;= w[i]; j--) &#123;           <span class="comment">// 递推方向发生了改变</span></span><br><span class="line">            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 函数略</span></span><br></pre></td></tr></table></figure>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><blockquote>
<p><a target="_blank" rel="noopener" href="http://nyoj.top/problem/311">NYOJ - 311</a></p>
</blockquote>
<p><strong>问题描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">01 背包中每个物品只有一个，所以只存在选或不选；</span><br><span class="line">完全背包中每个物品可以选取任意件。</span><br><span class="line"></span><br><span class="line">注意：本题要求是背包恰好装满背包时，求出最大价值总和是多少。如果不能恰好装满背包，输出 NO</span><br></pre></td></tr></table></figure>
<h4 id="二维-DP（无优化）-1"><a href="#二维-DP（无优化）-1" class="headerlink" title="二维 DP（无优化）"></a>二维 DP（无优化）</h4><ul>
<li><strong>直观思路</strong>：在 01 背包的基础上在加一层循环</li>
<li><strong>递推关系</strong>：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[0][j] &#x3D; 0</span><br><span class="line">dp[i][j] &#x3D; max&#123;dp[i - 1][j - k * w[i]] + k * v[i] | 0 &lt;&#x3D; k&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; N; i++) &#123;</span><br><span class="line">    for (int j &#x3D; 0; j &lt;&#x3D; V; j++) &#123;  &#x2F;&#x2F; 可能存在重量为 0 的物品</span><br><span class="line">        for (int k &#x3D; 0; k * w[i] &lt;&#x3D; j; k++)</span><br><span class="line">            dp[i][j] &#x3D; max(dp[i][j], dp[i-1][j - k*w[i]] + k*v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关于 <code>k</code> 的循环最坏可能从 0 到 <code>V</code>，因此时间复杂度为 <code>O(N*V^2)</code> </li>
</ul>
</li>
<li><strong>注意到</strong>：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; max&#123;dp[i - 1][j - k*w[i]] + k*v[i] | 0 &lt;&#x3D; k&#125;</span><br><span class="line">                                                ------</span><br><span class="line">         &#x3D; max&#123;dp[i - 1][j], max&#123;dp[i - 1][j - k*w[i]] + k*v[i]&#125; | 1 &lt;&#x3D; k&#125;</span><br><span class="line">                                                                   ------</span><br><span class="line">         &#x3D; max&#123;dp[i - 1][j], max&#123;dp[i - 1][(j-w[i]) - k*w[i]] + k*v[i] | 0 &lt;&#x3D; k&#125; + v[i]&#125;</span><br><span class="line">                                           --------                      ------  ------</span><br><span class="line">                             ---------------------------------------------------</span><br><span class="line">         &#x3D; max&#123;dp[i - 1][j], dp[i][j - w[i]] + v[i]&#125;</span><br><span class="line">                             ---------------</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; N; i++) &#123;</span><br><span class="line">    for (int j &#x3D; 0; j &lt;&#x3D; V; j++) &#123;</span><br><span class="line">        if (w[i] &gt; j)</span><br><span class="line">            dp[i][j] &#x3D; dp[i - 1][j];</span><br><span class="line">        else</span><br><span class="line">            dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - w[i]] + v[i]);</span><br><span class="line">        &#x2F;&#x2F;  dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); &#x2F;&#x2F; 对比 01 背包</span><br><span class="line">        &#x2F;&#x2F;                               ---------（唯一区别）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>完整代码</strong><ul>
<li>注意，这里要求的是恰好装满时的情况，所以需要将 <code>dp[i][0]</code> 全部初始化为 0，其他初始化为 <code>-INF</code><blockquote>
<p>以下代码因<strong>超内存</strong>无法通过 NYOJ 311；</p>
<p>可以 AC 的代码，请参考 <a href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E4%B8%80%E7%BB%B4-dp">完全背包（一维 DP）</a> 和 <a href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84">完全背包（滚动数组）</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NYOJ 311 会报超内存，所以无法测试</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x80000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> N, V;       <span class="comment">// N 表示物品种类的数目，V 表示背包的总容量</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;V);</span><br><span class="line">        vector&lt;int&gt; w(N + 1), v(N + 1);  // w 表示重量，v 表示价值</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;w[i], &amp;v[i]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(V + <span class="number">1</span>, inf));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w[i])</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[N][V] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[N][V]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二维-DP（滚动数组）-1"><a href="#二维-DP（滚动数组）-1" class="headerlink" title="二维 DP（滚动数组）"></a>二维 DP（滚动数组）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NYOJ 311-完全背包: http://nyoj.top/problem/311 （未通过测试，报运行时错误）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAX_V = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> N, V;       <span class="comment">// M 表示物品种类的数目，V 表示背包的总容量</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;V);</span><br><span class="line">        <span class="comment">//vector&lt;int&gt; w(N + 1), v(N + 1);  // w 表示重量，v 表示价值</span></span><br><span class="line">        <span class="comment">//for (int i = 1; i &lt;= N; i++)</span></span><br><span class="line">        <span class="comment">//    scanf(&quot;%d%d&quot;, &amp;w[i], &amp;v[i]);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//vector&lt;vector&lt;int&gt; &gt; dp(2, vector&lt;int&gt;(V + 1, -inf));</span></span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">2</span>][MAX_V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            fill(dp[i], dp[i] + MAX_V, -inf);</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> w, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;w, &amp;v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; w)</span><br><span class="line">                    dp[i &amp; <span class="number">1</span>][j] = dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i &amp; <span class="number">1</span>][j] = max(dp[(i - <span class="number">1</span>) &amp; <span class="number">1</span>][j], dp[i &amp; <span class="number">1</span>][j - w] + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[N][V] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[N &amp; <span class="number">1</span>][V]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    solve3();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="一维-DP-1"><a href="#一维-DP-1" class="headerlink" title="一维 DP"></a>一维 DP</h4></li>
</ul>
</li>
<li>核心代码与 01 背包一致，只有第二层循环的<strong>递推方向不同</strong></li>
<li><strong>完整代码</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NYOJ 311-完全背包: http://nyoj.top/problem/311</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_V = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x80000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> N, V;       <span class="comment">// M 表示物品种类的数目，V 表示背包的总容量</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;N, &amp;V);</span><br><span class="line">        <span class="comment">//vector&lt;int&gt; w(N + 1), v(N + 1);  // w 表示重量，v 表示价值</span></span><br><span class="line">        <span class="comment">//for (int i = 1; i &lt;= N; i++)</span></span><br><span class="line">        <span class="comment">//    scanf(&quot;%d%d&quot;, &amp;w[i], &amp;v[i]);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//vector&lt;int&gt; dp(V + 1, inf);   // 注意 NYOJ 的系统开辟稍大的 vector 就会导致超时</span></span><br><span class="line">        <span class="keyword">int</span> dp[MAX_V];</span><br><span class="line">        fill(dp, dp + MAX_V, inf);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> w, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;w, &amp;v);      <span class="comment">// 避免开辟新的内存 </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = w; j &lt;= V; j++) &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - w] + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[V] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dp[V]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    solve2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多重背包-TODO"><a href="#多重背包-TODO" class="headerlink" title="多重背包 TODO"></a>多重背包 TODO</h3></li>
</ul>
<h2 id="硬币问题"><a href="#硬币问题" class="headerlink" title="硬币问题"></a>硬币问题</h2><h3 id="硬币找零"><a href="#硬币找零" class="headerlink" title="硬币找零"></a>硬币找零</h3><blockquote>
<p>LeetCode - <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/description/">322. 零钱兑换</a></p>
</blockquote>
<p><strong>问题描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">给定不同面额的硬币 coins 和一个总金额 amount。</span><br><span class="line">编写一个函数来计算可以凑成总金额所需的最少的硬币个数。</span><br><span class="line">如果没有任何一种硬币组合能组成总金额，返回 -1。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">    输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11</span><br><span class="line">    输出: 3 </span><br><span class="line">    解释: 11 &#x3D; 5 + 5 + 1</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">    输入: coins &#x3D; [2], amount &#x3D; 3</span><br><span class="line">    输出: -1</span><br><span class="line">    </span><br><span class="line">说明:</span><br><span class="line">    你可以认为每种硬币的数量是无限的。</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<ul>
<li><strong>定义</strong>：<code>dp[i] := 组成总金额 i 时的最少硬币数</code></li>
<li><strong>初始化</strong>：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] &#x3D; 0       若 i&#x3D;0</span><br><span class="line">      &#x3D; INF     其他</span><br></pre></td></tr></table></figure></li>
<li><strong>状态转移</strong>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[j] &#x3D; min&#123; dp[j-coins[i]] + 1 | i&#x3D;0,..,n-1 &#125;</span><br><span class="line">    </span><br><span class="line">其中 coins[i] 表示硬币的币值，共 n 种硬币</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>C++</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> INF = n + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, INF)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=c; i&lt;=n; i++) &#123;            <span class="comment">//  i &gt;= c</span></span><br><span class="line">                dp[i] = min(dp[i], dp[i-c] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n] &lt; INF ? dp[n] : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="硬币组合"><a href="#硬币组合" class="headerlink" title="硬币组合"></a>硬币组合</h3><blockquote>
<p>LeetCode - <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change-2/description/">518. 零钱兑换 II</a></p>
</blockquote>
<p><strong>C++</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = coins.size();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = c; i &lt;= n; i++) &#123;</span><br><span class="line">                dp[i] += dp[i - c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/c996bbb77dd447d681ec6907ccfb488a">最长公共子序列</a>_牛客网 </p>
</blockquote>
<ul>
<li>求两个序列的最长公共字序列<ul>
<li>示例：s1: “<strong>B</strong>D<strong>C</strong>A<strong>BA</strong>“ 与 s2：”A<strong>BCB</strong>D<strong>A</strong>B” 的<strong>一个</strong>最长公共字序列为 “BCBA”</li>
<li>最长公共子序列不唯一，但是它们的长度是一致的</li>
<li>子序列不要求连续</li>
</ul>
</li>
</ul>
<p><strong>思路</strong></p>
<ul>
<li><strong>DP 定义</strong><ul>
<li><strong>记</strong> <code>s[0:i] := s 长度为 i 的**前缀**</code></li>
<li><strong>定义</strong> <code>dp[i][j] := s1[0:i] 和 s2[0:j] 最长公共子序列的长度</code></li>
</ul>
</li>
<li><strong>DP 初始化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; 0    当 i&#x3D;0 或 j&#x3D;0 时</span><br></pre></td></tr></table></figure></li>
<li><strong>DP 更新</strong><ul>
<li>当 <code>s1[i] == s2[j]</code> 时<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; dp[i-1][j-1] + 1</span><br></pre></td></tr></table></figure></li>
<li>当 <code>s1[i] != s2[j]</code> 时<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; max(dp[i-1][j], dp[i][j-1])</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>完整递推公式</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; 0                              当 i&#x3D;0 或 j&#x3D;0 时</span><br><span class="line">         &#x3D; dp[i-1][j-1] + 1               当 &#96;s1[i-1] &#x3D;&#x3D; s2[j-1]&#96; 时</span><br><span class="line">         &#x3D; max(dp[i-1][j], dp[i][j-1])    当 &#96;s1[i-1] !&#x3D; s2[j-1]&#96; 时</span><br></pre></td></tr></table></figure></li>
<li><strong>Code - C++</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LCS</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLCS</span><span class="params">(<span class="built_in">string</span> A, <span class="keyword">int</span> n, <span class="built_in">string</span> B, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 已经初始化为全 0，就不必再手动初始化 DP 了</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">                <span class="keyword">if</span> (A[i<span class="number">-1</span>] == B[j<span class="number">-1</span>])  <span class="comment">// 注意下标问题</span></span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = max(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/02e7cc263f8a49e8b1e1dc9c116f7602">最长公共子串</a>_牛客网 </p>
</blockquote>
</li>
</ul>
<p><strong>题目描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于两个字符串，请设计一个时间复杂度为&#96;O(m*n)&#96;的算法，求出两串的最长公共子串的长度。</span><br><span class="line">（这里的 m 和 n 为两串的长度）</span><br></pre></td></tr></table></figure>
<p><strong>思路 - 暴力求解</strong></p>
<div align="center"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g78kb88crbj305004ygls.jpg" height="300" /></div>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Longest_common_substring_problem">Longest common substring problem</a> - Wikipedia </p>
</blockquote>
<p>  暴力求解思路：每当找到一对元素相同时就<strong>斜向比较</strong><br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongestSubstring</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLongest</span><span class="params">(<span class="built_in">string</span> A, <span class="keyword">int</span> n, <span class="built_in">string</span> B, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp_ret = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (A[i] == B[j]) &#123;  <span class="comment">// 每当找到一对元素相同</span></span><br><span class="line">                    tmp_ret += <span class="number">1</span>;    <span class="comment">// 斜向比较</span></span><br><span class="line">                    <span class="keyword">int</span> tmp_i = i + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> tmp_j = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> (tmp_i &lt; n &amp;&amp; tmp_j &lt; m &amp;&amp; A[tmp_i++] == B[tmp_j++])  <span class="comment">// 注意边界</span></span><br><span class="line">                        tmp_ret++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret = max(ret, tmp_ret);  <span class="comment">// 记录最大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意：如果两个串完全相同的话，时间复杂度将退化为 <code>O(N^3)</code></li>
</ul>
<p><strong>思路 - DP</strong></p>
<ul>
<li><p><strong>DP 定义</strong></p>
<ul>
<li><strong>记</strong> <code>s[0:i] := s 长度为 i 的**前缀**</code></li>
<li><del><strong>定义</strong> <code>dp[i][j] := s1[0:i] 和 s2[0:j] 最长公共子串的长度</code></del></li>
<li><code>dp[i][j]</code> 只有当 <code>s1[i] == s2[j]</code> 的情况下才是 <code>s1[0:i] 和 s2[0:j] 最长公共子串的长度</code></li>
</ul>
</li>
<li><p><strong>DP 初始化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; 0    当 i&#x3D;0 或 j&#x3D;0 时</span><br></pre></td></tr></table></figure></li>
<li><p><strong>DP 更新</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; dp[i-1][j-1] + 1     if s[i] &#x3D;&#x3D; s[j]</span><br><span class="line">         &#x3D; ;                    else pass</span><br></pre></td></tr></table></figure></li>
<li><p><strong>Code</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongestSubstring</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLongest</span><span class="params">(<span class="built_in">string</span> A, <span class="keyword">int</span> n, <span class="built_in">string</span> B, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 已经初始化为全 0，就不必再手动初始化 DP 了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    ret = max(ret, dp[i][j]);         <span class="comment">// 相比最长公共子序列，增加了这行</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ;                                 <span class="comment">// 去掉了这行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>DP 优化</strong>：空间复杂度 <code>O(N)</code></p>
<ul>
<li>好不容易找到的优化为 <code>O(N)</code> 的代码；多数优化直接优化到了 <code>O(1)</code></li>
<li>因为内层循环是逆序的，所以有点不好理解，可以画一个矩阵手推 DP 的更新过程，很巧妙<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongestSubstring</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLongest</span><span class="params">(<span class="built_in">string</span> A, <span class="keyword">int</span> n, <span class="built_in">string</span> B, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; m) &#123;</span><br><span class="line">            swap(n, m);</span><br><span class="line">            swap(A, B);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i] != B[j]) &#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ret = max(ret, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>DP 优化</strong>：空间复杂度 <code>O(1)</code></p>
<ul>
<li>两个字符串的比较总是按一行一行或一列一列来比较，因此至少要保存一行的数据</li>
<li>而如果是按照斜向遍历，其实只要保存一个数据即可<div align="center"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g78kgyjxv2j30il0f5jvn.jpg" height="300" /></div>

</li>
</ul>
<p>斜向遍历的策略很多，下面的代码是从右上角（<code>row=0, col=m-1</code>）开始遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongestSubstring</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLongest</span><span class="params">(<span class="built_in">string</span> A, <span class="keyword">int</span> n, <span class="built_in">string</span> B, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>, col = m - <span class="number">1</span>; row &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = row;</span><br><span class="line">            <span class="keyword">int</span> j = col;</span><br><span class="line">            <span class="keyword">int</span> dp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i++] == B[j++])  <span class="comment">// 注意：无论走哪个分支，i 和 j 都会 ++ 一次</span></span><br><span class="line">                    dp += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                ret = max(ret, dp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (col &gt; <span class="number">0</span>) </span><br><span class="line">                col--;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                row++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码其实就是把下面的两段循环合并了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LongestSubstring</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLongest</span><span class="params">(<span class="built_in">string</span> A, <span class="keyword">int</span> n, <span class="built_in">string</span> B, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = m<span class="number">-1</span>; col &gt;= <span class="number">0</span>; col--) &#123;</span><br><span class="line">            dp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = col; i &lt; n &amp;&amp; j &lt; m; i++, j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i] == B[j])</span><br><span class="line">                    dp += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                ret = max(ret, dp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; n; row++) &#123;</span><br><span class="line">            dp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = row, j = <span class="number">0</span>; i &lt; n &amp;&amp; j &lt; m; i++, j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i] == B[j])</span><br><span class="line">                    dp += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                ret = max(ret, dp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="最长递增子序列（LIS）"><a href="#最长递增子序列（LIS）" class="headerlink" title="最长递增子序列（LIS）"></a>最长递增子序列（LIS）</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/585d46a1447b4064b749f08c2ab9ce66">最长递增子序列</a>_牛客网</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/description/">最长上升子序列</a> - LeetCode</p>
<blockquote>
<p>牛客假设给定的数组中不存在重复元素，LeetCode 可能存在重复元素</p>
</blockquote>
</blockquote>
<p><strong>问题描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对于一个数字序列，请设计一个复杂度为O(nlogn)的算法，返回该序列的最长上升子序列的长度</span><br><span class="line"></span><br><span class="line">测试样例：</span><br><span class="line">  [2,1,4,3,1,5,6],7</span><br><span class="line">返回：</span><br><span class="line">  4</span><br><span class="line">说明：</span><br><span class="line">  [1,3,5,6] 是其中一个最长递增子序列</span><br></pre></td></tr></table></figure>
<p><strong>思路0 - <code>O(N^2)</code></strong></p>
<ul>
<li>LIS 可以转化成 LCS (最长公共子序列) 问题</li>
<li>用另一个序列保存给定序列的<strong>排序</strong>结果 - <code>O(NlogN)</code></li>
<li>则问题转化为求这两个序列的 LCS 问题 - <code>O(N^2)</code></li>
</ul>
<p><strong>思路1 - <code>O(N^2)</code>解法</strong></p>
<ul>
<li><p><strong>DP 定义</strong></p>
<ul>
<li><strong>记</strong> <code>nums[0:i] := 序列 nums 的前 i 个元素构成的子序列</code></li>
<li><strong>定义</strong> <code>dp[i] := nums[0:i] 中 LIS 的长度</code></li>
<li>实际并没有严格按照这个定义，中间使用一个变量记录当前全局最长的 LIS</li>
</ul>
</li>
<li><p><strong>DP 初始化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[:] &#x3D; 1  &#x2F;&#x2F; 最长上升子序列的长度最短为 1</span><br></pre></td></tr></table></figure></li>
<li><p><strong>DP 更新 - <code>O(N^2)</code>的解法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i] &#x3D; max&#123;dp[j]&#125; + 1,  if nums[i] &gt; nums[j]</span><br><span class="line">      &#x3D; max&#123;dp[j]&#125;,      else</span><br><span class="line">where 0 &lt;&#x3D; j &lt; i</span><br></pre></td></tr></table></figure>
<p>如果只看这个递推公式，很可能会写出如下的<strong>错误代码</strong></p>
<details><summary><b>错误代码（点击展开）</b></summary> 

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 牛客网</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AscentSequence</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLongest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j])</span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i] = max(dp[i], dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>这段代码的问题在于 <code>dp[i]</code> 应该等于 <code>max&#123;dp[j]&#125;</code> 对应的那个 <code>dp[j]+1</code>，且<strong>只增加一次</strong></li>
<li>这么写可能会导致 <code>dp[i]</code> 被增加多次<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hapjin/p/5597658.html">动态规划求解最长递增子序列的长度 - hapjin</a> - 博客园 </p>
</blockquote>
</li>
</ul>
</details>
</li>
<li><p>下面是网上比较流行的一种<strong>递推公式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i] &#x3D; dp[j] + 1,  if nums[i] &gt; nums[j] &amp;&amp; dp[i] &lt; dp[j] + 1</span><br><span class="line">      &#x3D; pass,       else</span><br><span class="line">where 0 &lt;&#x3D; j &lt; i</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong>：此时并没有严格按照定义处理 dp，它只记录了当 <code>nums[i] &gt; nums[j] &amp;&amp; dp[i] &lt; dp[j] + 1</code> 时的 LIS；不满足该条件的情况<strong>跳过</strong>了；所以需要额外一个变量记录当前已知全局的 LIS</li>
</ul>
</li>
<li><p><strong>Code</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 牛客网</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AscentSequence</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLongest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j] &amp;&amp; dp[i] &lt; dp[j] + <span class="number">1</span>)</span><br><span class="line">                    dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            ret = max(ret, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>思路2 - <code>O(NlogN)</code></strong></p>
<ul>
<li><p>该解法的<strong>思想</strong>是：长度为 <code>i</code> 的 LIS 的<strong>尾元素</strong>应该大于长度为 <code>i-1</code> 的尾元素</p>
</li>
<li><p><strong>DP 定义</strong></p>
<ul>
<li><strong>定义</strong> <code>dp[i] := 长度为 i 的 LIS 的最小尾元素</code></li>
</ul>
</li>
<li><p><strong>DP 更新</strong></p>
<ul>
<li>二分查找 nums[j] 在 dp 中的 <del>upper_bound 位置</del> <strong>lower_bound 位置</strong><ul>
<li>upper_bound 位置指的是序列中第一个大于 nums[j] 的元素所在的位置</li>
<li>lower_bound 位置指的是序列中第一个大于等于 nums[j] 的元素所在的位置</li>
<li>C++ 中分别实现了 upper_bound 和 lower_bound，定义在 <code>&lt;algorithm&gt;</code> 中</li>
<li>如果在末尾，则插入；反之则替换</li>
</ul>
</li>
<li>upper_bound 只能用于不存在重复元素的情况；而 lower_bound 可以兼容两种情况</li>
</ul>
</li>
<li><p><strong>Code</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 牛客网</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AscentSequence</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLongest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 这里用 upper_bound 也可以</span></span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(dp.begin(), dp.end(), nums[j]);</span><br><span class="line">            <span class="keyword">if</span> (it == dp.end())</span><br><span class="line">                dp.push_back(nums[j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *it = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LeetCode</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 这里只能使用 lower_bound</span></span><br><span class="line">            <span class="keyword">auto</span> it_l = lower_bound(dp.begin(), dp.end(), nums[j]);</span><br><span class="line">            <span class="comment">// auto it_u = upper_bound(dp.begin(), dp.end(), nums[j]);</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (it_l == dp.end())</span><br><span class="line">                dp.push_back(nums[j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                *it_l = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/description/">最长回文子序列</a> - LeetCode</p>
</blockquote>
<p><strong>问题描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</span><br><span class="line"></span><br><span class="line">示例 1:</span><br><span class="line">  输入:</span><br><span class="line">    &quot;bbbab&quot;</span><br><span class="line">  输出:</span><br><span class="line">    4</span><br><span class="line">  一个可能的最长回文子序列为 &quot;bbbb&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<ul>
<li>相比最长回文子串，最长回文子序列更像<strong>最长公共子序列</strong>，只是改变了循环方向</li>
<li><strong>DP 定义</strong><ul>
<li><strong>记</strong> <code>s[i:j] := 字符串 s 在区间 [i:j] 上的子串</code></li>
<li><strong>定义</strong> <code>dp[i][j] := s[i:j] 上回文序列的长度</code></li>
</ul>
</li>
<li><strong>DP 初始化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][i]   &#x3D; 1  &#x2F;&#x2F; 单个字符也是一个回文序列</span><br></pre></td></tr></table></figure></li>
<li><strong>DP 更新</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; dp[i+1][j-1] + 2,              if s[i] &#x3D;&#x3D; s[j]</span><br><span class="line">         &#x3D; max(dp[i+1][j], dp[i][j-1]),   else</span><br><span class="line"></span><br><span class="line">比较一下 LCS 的递推公式</span><br><span class="line">dp[i][j] &#x3D; 0                              当 i&#x3D;0 或 j&#x3D;0 时</span><br><span class="line">         &#x3D; dp[i-1][j-1] + 1               当 &#96;s1[i-1] &#x3D;&#x3D; s2[j-1]&#96; 时</span><br><span class="line">         &#x3D; max(dp[i-1][j], dp[i][j-1])    当 &#96;s1[i-1] !&#x3D; s2[j-1]&#96; 时</span><br></pre></td></tr></table></figure></li>
<li><strong>Code</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)             <span class="comment">// 子串结束位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j<span class="number">-1</span>; i &gt;=<span class="number">0</span>; i--) &#123;     <span class="comment">// 子串开始位置</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j])</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/b4525d1d84934cf280439aeecc36f4af">最长回文子串</a>_牛客网 </p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/description/">最长回文子串</a> - LeetCode</p>
<blockquote>
<p>牛客网只需要输出长度；LeetCode 还需要输出一个具体的回文串</p>
</blockquote>
</blockquote>
<p><strong>问题描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</span><br><span class="line"></span><br><span class="line">示例 1：</span><br><span class="line">  输入: &quot;babad&quot;</span><br><span class="line">  输出: &quot;bab&quot;</span><br><span class="line">  注意: &quot;aba&quot;也是一个有效答案。</span><br></pre></td></tr></table></figure>
<p><strong>思路 - <code>O(N^2)</code></strong></p>
<ul>
<li><strong>DP 定义</strong><ul>
<li><strong>记</strong> <code>s[i:j] := 字符串 s 在区间 [i:j] 上的子串</code></li>
<li><strong>定义</strong> <code>dp[i][j] := s[i:j] 是否是一个回文串</code></li>
</ul>
</li>
<li><strong>DP 初始化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][i]   &#x3D; 1  &#x2F;&#x2F; 单个字符也是一个回文串</span><br></pre></td></tr></table></figure></li>
<li><strong>DP 更新</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; dp[i+1][j-1],  if s[i] &#x3D;&#x3D; s[j]</span><br><span class="line">         &#x3D; 0,             else</span><br><span class="line"></span><br><span class="line">注意到：如果 j - i &lt; 2 的话（比如 j&#x3D;2, i&#x3D;1），dp[i+1][j-1]&#x3D;dp[2][1] 会出现不符合 DP 定义的情况</span><br><span class="line">所以需要添加边界条件</span><br><span class="line">  </span><br><span class="line">  dp[i][i+1] &#x3D; 1,  if s[i] &#x3D;&#x3D; s[i+1]</span><br><span class="line">             &#x3D; 0,  else</span><br><span class="line">  </span><br><span class="line">该边界条件可以放在初始化部分完成；但是建议放在递推过程中完成过更好（为了兼容牛客和LeetCode）</span><br></pre></td></tr></table></figure></li>
<li><strong>Code</strong><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 牛客网 AC</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Palindrome</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLongestPalindrome</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;         <span class="comment">// 子串结束位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=j<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;  <span class="comment">// 子串开始位置</span></span><br><span class="line">                <span class="keyword">if</span> (j-i &lt; <span class="number">2</span>)</span><br><span class="line">                    dp[i][j] = (s[i]==s[j]) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i]==s[j])</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;  <span class="comment">// 因为 dp 全局初始化就是 0，这里其实可以不写</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j-i+<span class="number">1</span> &gt; len)</span><br><span class="line">                    len = j-i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LeetCode - 只要添加一个记录开始位置的变量即可</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> beg = <span class="number">0</span>;    <span class="comment">// 记录开始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;         <span class="comment">// 子串结束位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=j<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;  <span class="comment">// 子串开始位置</span></span><br><span class="line">                <span class="keyword">if</span> (j-i &lt; <span class="number">2</span>)</span><br><span class="line">                    dp[i][j] = (s[i]==s[j]) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i]==s[j])</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;  <span class="comment">// 因为 dp 全局初始化就是 0，这里其实可以不写</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j-i+<span class="number">1</span> &gt; len) &#123;</span><br><span class="line">                    beg = i;  <span class="comment">// 保存开始位置</span></span><br><span class="line">                    len = j-i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substr(beg, len);  <span class="comment">// 截取子串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Manacher 算法 - <code>O(N)</code></strong></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Stay-Hungry-Stay-Foolish/p/7622496.html">算法-最长回文子串(Manacher算法)</a> - 琼珶和予 - 博客园 </p>
</blockquote>
<h2 id="最大连续子序列和"><a href="#最大连续子序列和" class="headerlink" title="最大连续子序列和"></a>最大连续子序列和</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/afe7c043f0644f60af98a0fba61af8e7">最大连续子序列</a>_牛客网 </p>
<blockquote>
<p>牛客网要求同时输出最大子序列的首尾元素</p>
</blockquote>
</blockquote>
<p><strong>思路 - 基本问题：只输出最大连续子序列和</strong></p>
<ul>
<li><p><strong>DP 定义</strong></p>
<ul>
<li><strong>记</strong> <code>a[0:i] := 序列 a 在区间 [0:i] 上的子序列</code></li>
<li><strong>定义</strong> <code>dp[i] := a[0:i] 上的最大子序列和</code></li>
<li>实际并没有严格按照上面的定义，中间使用一个变量记录当前全局的最大连续子序列和</li>
</ul>
</li>
<li><p><strong>DP 初始化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[0] &#x3D; a[0]</span><br></pre></td></tr></table></figure></li>
<li><p><strong>DP 更新</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 只要 dp[i] &gt; 0 就一直累加下去，一旦小于 0 就重新开始</span><br><span class="line">dp[i] &#x3D; dp[i-1] + a[i],     if dp[i-1] &gt; 0</span><br><span class="line">      &#x3D; a[i],               else</span><br><span class="line"></span><br><span class="line">ret &#x3D; max&#123;ret, dp[i]&#125;       &#x2F;&#x2F; 只要大于 0 就累加会导致 dp[i] 保存的并不是 a[0:i] 中的最大连续子序列和</span><br><span class="line">                            &#x2F;&#x2F; 所以需要一个变量保存当前全局的最大连续子序列和</span><br></pre></td></tr></table></figure>
<details><summary><b>直观实现-无优化-空间复杂度`O(N)`（点击展开）</b></summary> 

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i - <span class="number">1</span>] &gt; <span class="number">0</span>)</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + a[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i] = a[i];</span><br><span class="line"></span><br><span class="line">            ret = max(ret, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输入</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">1 5 -3 2 4</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">1 -2 3 4 -10 6</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">-3 -1 -2 -5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</details>
</li>
<li><p><strong>DP 优化</strong></p>
<p>注意到每次递归实际只用到了 <code>dp[i-1]</code>，实际只要用到一个变量，空间复杂度 <code>O(1)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> max_cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max_cur &gt; <span class="number">0</span>)       <span class="comment">// 如果大于 0 就一直累加</span></span><br><span class="line">                max_cur += a[i];</span><br><span class="line">            <span class="keyword">else</span>                   <span class="comment">// 一旦小于 0 就重新开始</span></span><br><span class="line">                max_cur = a[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (max_cur &gt; ret)     <span class="comment">// 保存找到的最大结果</span></span><br><span class="line">                ret = max_cur;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以上可以简写成下面两行代码</span></span><br><span class="line">            <span class="comment">//max_cur = max(max_cur + a[i], a[i]);</span></span><br><span class="line">            <span class="comment">//ret = max(ret, max_cur);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>思路 - 输出区间/首尾</strong></p>
<ul>
<li>增加两个变量即可</li>
<li>注意：题目要求，如果序列中全是负数，则输出 0，以及整个序列的首尾元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 牛客网 AC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = INT_MIN;</span><br><span class="line">        <span class="keyword">int</span> max_cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> beg = a[<span class="number">0</span>], end = a[n<span class="number">-1</span>];  <span class="comment">// 输出首尾</span></span><br><span class="line">        <span class="comment">// int beg = 0, end = n-1;     // 输出区间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tmp_beg;  <span class="comment">// 保存临时 beg</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max_cur &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                max_cur += a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                max_cur = a[i];</span><br><span class="line">                tmp_beg = a[i];</span><br><span class="line">                <span class="comment">// tmp_beg = i;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (max_cur &gt; ret) &#123;  <span class="comment">// &gt; 表明保存的是第一次出现的最大和，&gt;= 则为最后一次（未验证）</span></span><br><span class="line">                ret = max_cur;</span><br><span class="line">                beg = tmp_beg;</span><br><span class="line">                end = a[i];  <span class="comment">// 输出首尾</span></span><br><span class="line">                <span class="comment">// end = i;  // 输出区间</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, <span class="number">0</span>, a[<span class="number">0</span>], a[n<span class="number">-1</span>]);</span><br><span class="line">            <span class="comment">// printf(&quot;%d %d %d\n&quot;, 0, 0, n-1);</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, ret, beg, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    foo3();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><blockquote>
<p>LeetCode-<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance/description/">编辑距离</a></p>
</blockquote>
<p><strong>问题描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数。</span><br><span class="line"></span><br><span class="line">你可以对一个单词进行如下三种操作：</span><br><span class="line">  插入一个字符</span><br><span class="line">  删除一个字符</span><br><span class="line">  替换一个字符</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line">  输入: word1 &#x3D; &quot;horse&quot;, word2 &#x3D; &quot;ros&quot;</span><br><span class="line">  输出: 3</span><br><span class="line">  解释: </span><br><span class="line">  horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)</span><br><span class="line">  rorse -&gt; rose (删除 &#39;r&#39;)</span><br><span class="line">  rose -&gt; ros (删除 &#39;e&#39;)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong>：编辑距离指的是将 <strong>word1 转换成 word2</strong></li>
</ul>
<p><strong>思路</strong></p>
<ul>
<li><p>用一个 dp 数组维护两个字符串的<strong>前缀</strong>编辑距离</p>
</li>
<li><p><strong>DP 定义</strong></p>
<ul>
<li><strong>记</strong> <code>word[0:i] := word 长度为 i 的**前缀子串**</code></li>
<li><strong>定义</strong> <code>dp[i][j] := 将 word1[0:i] 转换为 word2[0:j] 的操作数</code></li>
</ul>
</li>
<li><p><strong>初始化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] &#x3D; i  &#x2F;&#x2F; 每次从 word1 删除一个字符</span><br><span class="line">dp[0][j] &#x3D; j  &#x2F;&#x2F; 每次向 word1 插入一个字符</span><br></pre></td></tr></table></figure></li>
<li><p><strong>递推公式</strong></p>
<ul>
<li><code>word1[i] == word1[j]</code> 时<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; dp[i-1][j-1]</span><br></pre></td></tr></table></figure></li>
<li><code>word1[i] != word1[j]</code> 时，有三种更新方式，<strong>取最小</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; word[1:i] 表示 word 长度为 i 的前缀子串</span><br><span class="line">dp[i][j] &#x3D; min(&#123; dp[i-1][j]   + 1 ,     &#x2F;&#x2F; 将 word1[1:i-1] 转换为 word2[1:j] 的操作数 + 删除 word1[i] 的操作数(1)</span><br><span class="line">                 dp[i][j-1]   + 1 ,     &#x2F;&#x2F; 将 word1[0:i] 转换为 word2[0:j-1] 的操作数 + 将 word2[j] 插入到 word1[0:i] 之后的操作数(1)</span><br><span class="line">                 dp[i-1][j-1] + 1 &#125;)    &#x2F;&#x2F; 将 word1[0:i-1] 转换为 word2[0:j-1] 的操作数 + 将 word1[i] 替换为 word2[j] 的操作数(1)</span><br></pre></td></tr></table></figure>
<!-- - **注意到** `dp[i][j]` 是单调的，因此可以将整个过程归纳为
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    dp[i][j] &#x3D; min(&#123; dp[i-1][j]   + 1 ,</span><br><span class="line">                     dp[i][j-1]   + 1 ,</span><br><span class="line">                     dp[i-1][j-1] + (int)(word1[i] &#x3D;&#x3D; word1[j]) &#125;)</span><br><span class="line">    &#96;&#96;&#96; --&gt;</span><br><span class="line">- **C++**</span><br><span class="line">  &#96;&#96;&#96;C++</span><br><span class="line">  class Solution &#123;</span><br><span class="line">  public:</span><br><span class="line">      int minDistance(string word1, string word2) &#123;</span><br><span class="line">          int m &#x3D; word1.length();</span><br><span class="line">          int n &#x3D; word2.length();</span><br><span class="line">          vector&lt;vector&lt;int&gt; &gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; 初始化 dp</span><br><span class="line">          for (int i &#x3D; 1; i &lt;&#x3D; m; i++)</span><br><span class="line">              dp[i][0] &#x3D; i;</span><br><span class="line">          for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">              dp[0][j] &#x3D; j;</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; 更新 dp</span><br><span class="line">          for (int i &#x3D; 1; i &lt;&#x3D;m; i++)</span><br><span class="line">              for (int j &#x3D; 1; j &lt;&#x3D; n; j++)</span><br><span class="line">                  if (word1[i - 1] &#x3D;&#x3D; word2[j - 1])</span><br><span class="line">                      dp[i][j] &#x3D; dp[i - 1][j - 1];</span><br><span class="line">                  else</span><br><span class="line">                      dp[i][j] &#x3D; min(&#123; dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] &#125;)  + 1;</span><br><span class="line">              </span><br><span class="line">          return dp[m][n];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>DP 优化</strong></p>
<ul>
<li>注意到每次更新 <code>dp[i][j]</code> 只需要用到 <code>dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]</code>。因此实际上不需要用到二维 DP</li>
<li>具体见下方代码</li>
</ul>
<details><summary><b>Code - 优化为一维 DP（点击展开）</b></summary> 

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = word1.length(), n = word2.length();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">cur</span><span class="params">(m + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            cur[i] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> pre = cur[<span class="number">0</span>];</span><br><span class="line">            cur[<span class="number">0</span>] = j;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = cur[i];</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>])</span><br><span class="line">                    cur[i] = pre;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    cur[i] = min(pre + <span class="number">1</span>, min(cur[i] + <span class="number">1</span>, cur[i - <span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">                pre = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur[m]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</details>


</li>
</ul>
<h2 id="矩阵中的最大正方形"><a href="#矩阵中的最大正方形" class="headerlink" title="矩阵中的最大正方形"></a>矩阵中的最大正方形</h2><blockquote>
<p>LeetCode-<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximal-square/description/">221. 最大正方形</a></p>
</blockquote>
<p><strong>问题描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在一个由 0 和 1 组成的二维矩阵 M 内，找到只包含 1 的最大正方形，并返回其面积。</span><br><span class="line"></span><br><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: </span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p><strong>思路</strong></p>
<ul>
<li><strong>DP 定义</strong>：<code>dp[i][j] := 以 M[i][j] 为正方形**右下角**所能找到的最大正方形的边长</code><ul>
<li>注意保存的是边长</li>
<li>因为 <code>dp</code> 保存的不是全局最大值，所以需要用一个额外变量更新结果</li>
</ul>
</li>
<li><strong>初始化</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][0] &#x3D; M[i][0]</span><br><span class="line">dp[0][j] &#x3D; M[0][j]</span><br></pre></td></tr></table></figure></li>
<li><strong>递推公式</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; min&#123;dp[i-1][j], </span><br><span class="line">               dp[i][j-1], </span><br><span class="line">               dp[i-1][j-1]&#125; + 1  若 M[i][j] &#x3D;&#x3D; 1</span><br><span class="line">         &#x3D; 0                      否则</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到，本题的递推公式与 <a href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB">编辑距离</a> 完全一致</p>
</blockquote>
</li>
</ul>
<p><strong>C++</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (M.empty() || M[<span class="number">0</span>].empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> row = M.size();</span><br><span class="line">        <span class="keyword">auto</span> col = M[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = M[i][<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            mx = max(mx, dp[i][<span class="number">0</span>]);         <span class="comment">// 别忘了这里也要更新 mx</span></span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = M[<span class="number">0</span>][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            mx = max(mx, dp[<span class="number">0</span>][j]);         <span class="comment">// 别忘了这里也要更新 mx</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;row; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (M[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = min(&#123; dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &#125;) + <span class="number">1</span>;</span><br><span class="line">                    mx = max(mx, dp[i][j]); <span class="comment">// 更新 mx</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mx * mx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="鹰蛋问题"><a href="#鹰蛋问题" class="headerlink" title="鹰蛋问题"></a>鹰蛋问题</h2><blockquote>
<p>Power Eggs <a target="_blank" rel="noopener" href="http://acm.zcmu.edu.cn/JudgeOnline/problem.php?id=1894">http://acm.zcmu.edu.cn/JudgeOnline/problem.php?id=1894</a></p>
</blockquote>
<p><strong>问题描述</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">教授手上有&#96;M&#96;个一模一样的鹰蛋，教授想研究这些蛋的硬度&#96;E&#96;，测试方法是将蛋从高为&#96;N&#96;层的楼上不断自由落下；</span><br><span class="line">每个蛋在&#96;E+1&#96;层及以上掉下都会碎，而在&#96;E&#96;层及以下不会碎；每个蛋可以重复测试直到它碎了为止。</span><br><span class="line"></span><br><span class="line">例如：蛋从第 1 层掉下碎了，则&#96;E&#x3D;0&#96;；蛋从第&#96;N&#96;层掉下未碎，则&#96;E&#x3D;N&#96;。</span><br><span class="line"></span><br><span class="line">求在给定&#96;M&#96;和&#96;N&#96;下为了确定&#96;E&#96;在**最坏情况下**需要测试的最少次数。</span><br><span class="line">如果比较的次数大于 32，输出 &quot;Impossible&quot;。</span><br><span class="line"></span><br><span class="line">范围：1 ≤ N ≤ 2000000007，1 ≤ K ≤ 32</span><br><span class="line"></span><br><span class="line">示例：&#96;N&#x3D;10, K&#x3D;1&#96;，则&#96;ans&#x3D;10&#96;</span><br><span class="line">说明：如果只有一个蛋，那么只能将这个蛋一层层往上尝试；</span><br><span class="line">  因此在最坏情况下，它最少要测试 10 次才能确定 &#96;E&#96;</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong></p>
<ul>
<li>如果只有 <code>M=1</code> 个蛋，那么只能从第一层开始一层一层往上尝试，最坏情况下的最少次数为 <code>N</code></li>
<li>如果蛋的数量足够多，那么问题转变为二分查找，最坏情况下的最少次数为 <strong><code>logN</code> 上取整</strong></li>
</ul>
<p><strong>思路</strong></p>
<ul>
<li><p><strong>DP 定义</strong>：<code>dp[i][j] := i 个蛋比较 j 次所能确定的最高楼层</code></p>
</li>
<li><p><strong>DP 初始化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][1] &#x3D; 1  &#x2F;&#x2F; i 个蛋比较 1 次所能确定的最高楼层是 1</span><br><span class="line">dp[1][j] &#x3D; j  &#x2F;&#x2F; 1 个蛋比较 j 次所能确定的最高楼层为 j</span><br></pre></td></tr></table></figure></li>
<li><p><strong>DP 更新</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] &#x3D; dp[i][j-1] + dp[i-1][j-1] + 1</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：TODO（不理解是如何得到这个递推式的）</p>
</li>
<li><p><strong>C++</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OJ 地址：http://acm.zcmu.edu.cn/JudgeOnline/problem.php?id=1894</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_K = <span class="number">32</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_T = <span class="number">32</span> + <span class="number">1</span>;</span><br><span class="line">LL dp[MAX_K][MAX_T];          <span class="comment">// 使用 LL 防止溢出，long 不保证比 int 更大</span></span><br><span class="line"><span class="comment">// dp[i][j] := i 个蛋比较 j 次所能确定的最高楼层</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAX_K; i++)</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; MAX_T; j++)</span><br><span class="line">        dp[<span class="number">1</span>][j] = j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAX_K; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; MAX_T; j++)</span><br><span class="line">            dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="comment">//printf(&quot;%lld&quot;, dp[32][32]);  // 4294967295 == 2^32 - 1，用 int 会溢出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T;          <span class="comment">// 1 ≤ T ≤ 10000</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> N, K;   <span class="comment">// 1 ≤ N ≤ 2000000007 &lt; 2^31, 1 ≤ K ≤ 32</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;N, &amp;K);</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; MAX_T; j++) &#123;</span><br><span class="line">            <span class="comment">// 注意：dp[i][j] 表示的是 i 个蛋比较 j 次所能确定的最高楼层</span></span><br><span class="line">            <span class="keyword">if</span> (dp[K][j] &gt;= N) &#123;</span><br><span class="line">                ret = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Reference</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://wenku.baidu.com/view/7d57940ef12d2af90242e6ac.html">从《鹰蛋》一题浅析对动态规划算法的优化</a>_百度文库 </li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>动态规划专题</p><p><a href="https://huzhiliang.com/2017/09/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">https://huzhiliang.com/2017/09/23/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>ฅ´ω`ฅ</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2017-09-23</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2019-11-18</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a><a class="link-muted mr-2" rel="tag" href="/tags/%E4%B8%93%E9%A2%98/">专题</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2017/10/07/Numpy%E7%AC%94%E8%AE%B0/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Numpy笔记</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2017/07/08/Python%E6%83%AF%E4%BE%8B/"><span class="level-item">Python惯例</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Your name"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Your name</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">161</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">97</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener" id="widget-follow">微博 Weibo</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div><a class="link-more button is-light is-small size-small" href="/friends/">查看更多</a></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Golang/"><span class="level-start"><span class="level-item">Golang</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Kaggle/"><span class="level-start"><span class="level-item">Kaggle</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">85</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">26</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">深度学习</span></span><span class="level-end"><span class="level-item tag">29</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/CNN/"><span class="level-start"><span class="level-item">CNN</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">迁移学习</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%A0%B4%E8%A7%A3/"><span class="level-start"><span class="level-item">破解</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">英语学习</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-03-05T05:41:28.000Z">2020-03-05</time></p><p class="title"><a href="/2020/03/05/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BACRF-%E4%B8%89-%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%BB%B4%E7%89%B9%E6%AF%94%E7%AE%97%E6%B3%95%E8%A7%A3%E7%A0%81/">条件随机场CRF(三) 模型学习与维特比算法解码</a></p><p class="categories"><a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a> / <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP/">NLP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-03-04T08:24:55.000Z">2020-03-04</time></p><p class="title"><a href="/2020/03/04/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BACRF-%E4%BA%8C-%E5%89%8D%E5%90%91%E5%90%8E%E5%90%91%E7%AE%97%E6%B3%95%E8%AF%84%E4%BC%B0%E6%A0%87%E8%AE%B0%E5%BA%8F%E5%88%97%E6%A6%82%E7%8E%87/">条件随机场CRF(二) 前向后向算法评估标记序列概率</a></p><p class="categories"><a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a> / <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP/">NLP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-03-03T02:59:49.000Z">2020-03-03</time></p><p class="title"><a href="/2020/03/03/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BACRF-%E4%B8%80-%E4%BB%8E%E9%9A%8F%E6%9C%BA%E5%9C%BA%E5%88%B0%E7%BA%BF%E6%80%A7%E9%93%BE%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA/">条件随机场CRF(一)从随机场到线性链条件随机场</a></p><p class="categories"><a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a> / <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP/">NLP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-03-02T02:46:01.000Z">2020-03-02</time></p><p class="title"><a href="/2020/03/02/%E6%96%87%E6%9C%AC%E6%8C%96%E6%8E%98%E7%9A%84%E5%88%86%E8%AF%8D%E5%8E%9F%E7%90%86/">文本挖掘的分词原理</a></p><p class="categories"><a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a> / <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP/">NLP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-02-20T01:01:00.000Z">2020-02-20</time></p><p class="title"><a href="/2020/02/20/optimize-water-distribution-in-a-village/">optimize water distribution in a village</a></p><p class="categories"><a href="/categories/LeetCode/">LeetCode</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">33</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/01/"><span class="level-start"><span class="level-item">一月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">十二月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/11/"><span class="level-start"><span class="level-item">十一月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/10/"><span class="level-start"><span class="level-item">十月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/09/"><span class="level-start"><span class="level-item">九月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/07/"><span class="level-start"><span class="level-item">七月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/06/"><span class="level-start"><span class="level-item">六月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/05/"><span class="level-start"><span class="level-item">五月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/03/"><span class="level-start"><span class="level-item">三月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/02/"><span class="level-start"><span class="level-item">二月 2017</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/04/"><span class="level-start"><span class="level-item">四月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/02/"><span class="level-start"><span class="level-item">二月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Array/"><span class="tag">Array</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Attention/"><span class="tag">Attention</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Binary-Tree/"><span class="tag">Binary Tree</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CFG/"><span class="tag">CFG</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CNN/"><span class="tag">CNN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CPU/"><span class="tag">CPU</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CYK/"><span class="tag">CYK</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Caffee/"><span class="tag">Caffee</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Facebook/"><span class="tag">Facebook</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GAN/"><span class="tag">GAN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GBDT/"><span class="tag">GBDT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GPU/"><span class="tag">GPU</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GRN/"><span class="tag">GRN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GloVe/"><span class="tag">GloVe</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Google-apac/"><span class="tag">Google apac</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go%E8%AF%AD%E8%A8%80/"><span class="tag">Go语言</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Greedy/"><span class="tag">Greedy</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HMM/"><span class="tag">HMM</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IBM-Modes/"><span class="tag">IBM Modes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KL%E6%95%A3%E5%BA%A6/"><span class="tag">KL散度</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LSTM/"><span class="tag">LSTM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LeetCode/"><span class="tag">LeetCode</span><span class="tag">31</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Lexicalized-PCFG/"><span class="tag">Lexicalized PCFG</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Lexized-PCFG/"><span class="tag">Lexized PCFG</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Log-Linear-Models/"><span class="tag">Log-Linear Models</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Machine-Learning/"><span class="tag">Machine Learning</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PCFG/"><span class="tag">PCFG</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paper/"><span class="tag">Paper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Programmer/"><span class="tag">Programmer</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Pytorch/"><span class="tag">Pytorch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Queue/"><span class="tag">Queue</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RNN/"><span class="tag">RNN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Seq2seq/"><span class="tag">Seq2seq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tagging/"><span class="tag">Tagging</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tencent/"><span class="tag">Tencent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tensorflow/"><span class="tag">Tensorflow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VIP/"><span class="tag">VIP</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Viterbi/"><span class="tag">Viterbi</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Word-representation/"><span class="tag">Word representation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/XGBoost/"><span class="tag">XGBoost</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/exhaustive-search/"><span class="tag">exhaustive search</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/github/"><span class="tag">github</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/numpy/"><span class="tag">numpy</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spark/"><span class="tag">spark</span><span class="tag">23</span></a></div><div class="control"><a class="tags has-addons" href="/tags/turtle/"><span class="tag">turtle</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/word2vec/"><span class="tag">word2vec</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%93%E9%A2%98/"><span class="tag">专题</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"><span class="tag">二分搜索</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/"><span class="tag">二分搜索树</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86%E6%A0%91/"><span class="tag">二分树</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"><span class="tag">二进制</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"><span class="tag">优化算法</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E7%B1%BB/"><span class="tag">分类</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E8%AF%8D/"><span class="tag">分词</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%91%E6%8C%87offer/"><span class="tag">剑指offer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E5%9B%9E%E5%BD%92/"><span class="tag">动态回归</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%9E%E5%BD%92/"><span class="tag">回归</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E8%AE%BA/"><span class="tag">图论</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8E%92%E5%BA%8F/"><span class="tag">排序</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/"><span class="tag">数学原理</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"><span class="tag">数据分析</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA/"><span class="tag">条件随机场</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6/"><span class="tag">极大似然</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A8%A1%E5%9E%8B%E5%8E%8B%E7%BC%A9/"><span class="tag">模型压缩</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2/"><span class="tag">模型部署</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">深度学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%89%88%E6%9D%83/"><span class="tag">版权</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%89%B9%E5%BE%81%E6%8A%BD%E5%8F%96/"><span class="tag">特征抽取</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AC%94%E8%AE%B0/"><span class="tag">笔记</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"><span class="tag">算法原理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/"><span class="tag">算法复杂度</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"><span class="tag">线性模型</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%84%E5%90%88%E6%A0%91/"><span class="tag">组合树</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C/"><span class="tag">经典网络</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/"><span class="tag">统计机器翻译</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"><span class="tag">网易云音乐</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%81%9A%E7%B1%BB/"><span class="tag">聚类</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"><span class="tag">背包问题</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%84%9A%E6%9C%AC/"><span class="tag">脚本</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%AD%E6%B3%95/"><span class="tag">语法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"><span class="tag">语言模型</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B6%85%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/"><span class="tag">超参数调整</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/"><span class="tag">迁移学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%92%E5%BD%92/"><span class="tag">递归</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%82%AE%E4%BB%B6/"><span class="tag">邮件</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%93%BE%E8%A1%A8/"><span class="tag">链表</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%99%8D%E7%BB%B4/"><span class="tag">降维</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95%E4%B8%93%E5%9C%BA/"><span class="tag">面试专场</span><span class="tag">2</span></a></div></div></div></div></div><div class="card widget" id="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/" alt="MCFON" height="28"><img class="logo-img-dark" src="/" alt="MCFON" height="28"></a><p class="is-size-7"><span>&copy; 2020 ฅ´ω`ฅ</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/imaegoo/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><a href="http://www.miitbeian.gov.cn" target="_blank">豫ICP备18017229号</a> - </p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><div class="searchbox-pinyin"><label class="checkbox"><input id="search-by-pinyin" type="checkbox" checked="checked"><span> 拼音检索</span></label></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/imaegoo/pinyin.js" defer></script><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script type="text/javascript" src="/js/imaegoo/imaegoo.js"></script><script type="text/javascript" src="/js/imaegoo/universe.js"></script><script type="text/javascript" src="/js/live2d/autoload.js"></script></body></html>