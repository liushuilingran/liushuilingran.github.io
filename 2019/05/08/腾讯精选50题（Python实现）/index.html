<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>腾讯精选50题（Python实现） - MCFON</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="MCFON"><meta name="msapplication-TileImage" content="/images/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="MCFON"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="前言 代码精炼是 Python 的核心，同时能够反应对于语言的熟练程度，本项目目的在于汇总 leet code 最短最优雅的解法，拒绝长篇大论，缩短学习周期，掌握各种技巧，助您在面试中写出令人眼前一亮的解答，给考官留个好印象。"><meta property="og:type" content="blog"><meta property="og:title" content="腾讯精选50题（Python实现）"><meta property="og:url" content="https://huzhiliang.com/2019/05/08/%E8%85%BE%E8%AE%AF%E7%B2%BE%E9%80%8950%E9%A2%98%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89/"><meta property="og:site_name" content="MCFON"><meta property="og:description" content="前言 代码精炼是 Python 的核心，同时能够反应对于语言的熟练程度，本项目目的在于汇总 leet code 最短最优雅的解法，拒绝长篇大论，缩短学习周期，掌握各种技巧，助您在面试中写出令人眼前一亮的解答，给考官留个好印象。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://huzhiliang.com/img/og_image.png"><meta property="article:published_time" content="2019-05-08T07:25:31.000Z"><meta property="article:modified_time" content="2019-10-30T18:56:19.063Z"><meta property="article:author" content="ฅ´ω`ฅ"><meta property="article:tag" content="Tencent"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://huzhiliang.com/2019/05/08/%E8%85%BE%E8%AE%AF%E7%B2%BE%E9%80%8950%E9%A2%98%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89/"},"headline":"MCFON","image":["https://huzhiliang.com/img/og_image.png"],"datePublished":"2019-05-08T07:25:31.000Z","dateModified":"2019-10-30T18:56:19.063Z","author":{"@type":"Person","name":"ฅ´ω`ฅ"},"description":"前言 代码精炼是 Python 的核心，同时能够反应对于语言的熟练程度，本项目目的在于汇总 leet code 最短最优雅的解法，拒绝长篇大论，缩短学习周期，掌握各种技巧，助您在面试中写出令人眼前一亮的解答，给考官留个好印象。"}</script><link rel="canonical" href="https://huzhiliang.com/2019/05/08/%E8%85%BE%E8%AE%AF%E7%B2%BE%E9%80%8950%E9%A2%98%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89/"><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/" alt="MCFON" height="28"><img class="logo-img-dark" src="/" alt="MCFON" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-05-08T07:25:31.000Z" title="2019-05-08T07:25:31.000Z">2019-05-08</time>发表</span><span class="level-item"><time dateTime="2019-10-30T18:56:19.063Z" title="2019-10-30T18:56:19.063Z">2019-10-31</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/LeetCode/">LeetCode</a></span><span class="level-item">1 小时读完 (大约10923个字)</span><span class="level-item leancloud_visitors" id="/2019/05/08/%E8%85%BE%E8%AE%AF%E7%B2%BE%E9%80%8950%E9%A2%98%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89/" data-flag-title="腾讯精选50题（Python实现）"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="twikoo_visitors"><i class="fa fa-spinner fa-spin"></i></span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">腾讯精选50题（Python实现）</h1><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>代码精炼是 Python 的核心，同时能够反应对于语言的熟练程度，本项目目的在于汇总 leet code 最短最优雅的解法，拒绝长篇大论，缩短学习周期，掌握各种技巧，助您在面试中写出令人眼前一亮的解答，给考官留个好印象。<a id="more"></a></li>
<li>为什么我们追求最短?1.短代码更pythonic，而且通常能够避免一些冗余过程。2.除了刷题掌握算法思路之外，我们更追求深入理解和掌握python,学会套用技巧，举一反三。3.真正面试的时候不一定要这么短，可以适当展开几行(O_o 除非你就是想秀其他人一脸 😅)，保证思路更清晰，相信就算展开几行也会比其他题解短很多吧。4.刷题很累，找点乐子，送给自己一些成就感吧。5.所有已收录代码都是优中选优，有利于缩短学习周期，除了短代码外，另有常规解法作为补充。</li>
<li>项目持续更新中，优先使用 python3，不支持的题目使用 python2 代替，如果您有更短更优雅的解法希望分享的话欢迎联系更新~  [直接发issue 或 fork，记得留下署名和联系方式 :panda_face:] 鉴于追求的主题，此项目收录 1.在代码量上明显优于现有解的最短代码 2.思路更高效的一般解法（作为补充放在首选解之后） [题目自带的代码不计入代码量]</li>
<li>如果您对当前解析有任何疑问，咱们 issue 见~</li>
<li>由于CSDN博客更新需要人工审核比较慢，所以迁移到github上，优先更新github内容。</li>
<li>为了快速找到题目可以按 [<strong>Ctrl键 + F键</strong>] 输入题目序号或名字定位。<h1 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h1></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problemset/all/?listId=ex0k24j">:penguin: 腾讯精选练习</a>（50题: 25简单 21中等 4困难） 代码行数 总计：140行 平均：2.8行 <a href="tencent50.png">:bookmark_tabs: 题目详情</a> <h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2></li>
<li>与本项目有关联的，是一个<a target="_blank" rel="noopener" href="https://github.com/cy69855522/Clearest-LeetCode-Cpp-Solutions"> C++最清晰题解汇总 </a>👻。Python篇注重熟悉语言特性，充分利用高级语言提供的已内置的功能避免冗余编码，最低成本地解决问题。C++篇注重通用思想，分专题逐个击破，深入探究算法流程。俩者同时服用效果更佳，只想学一门也不必担心，俩个项目相辅相成，Python篇会在题解之后添加常规解法作为补充，并聚合C++篇精华总结一套运用python独特技巧的专题，C++篇会利用python题解的思想优化代码，保证代码简洁，可读性高。</li>
<li>🌟 推荐刷题路线：<a href="#%E4%B8%93%E9%A2%98">专题剖析</a> → <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problemset/all/?listId=ex0k24j">腾讯精选50题</a> → <a href="#%E8%A7%A3%E6%9E%90">全题解析</a></li>
</ul>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>默认已看过题目，🤡 没看过的话点标题可以跳转链接</p>
<h2 id="1-Two-Sum-2行"><a href="#1-Two-Sum-2行" class="headerlink" title="1. Two Sum 2行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum/">1. Two Sum 2行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        d = &#123;target - n: i <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums)&#125;</span><br><span class="line">        <span class="keyword">return</span> [[d[n], i] <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums) <span class="keyword">if</span> n <span class="keyword">in</span> d <span class="keyword">and</span> d[n] &gt; i][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>O(N)时间效率的快速解法，用字典记录 需要的值:当前索引</p>
</li>
<li><p>如果字典中存在相同的数字，那么将会记录比较大的那个索引，因此可以用<code>d[n] &gt; i</code>来避免一个元素重复选择</p>
</li>
<li><p>改成 for 循环加 break 再加动态修改字典能更快一点</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums): </span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> d: <span class="keyword">return</span> [d[n], i]</span><br><span class="line">            d[target-n] = i</span><br></pre></td></tr></table></figure>
<h2 id="2-Add-Two-Numbers-5行"><a href="#2-Add-Two-Numbers-5行" class="headerlink" title="2. Add Two Numbers 5行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/add-two-numbers/">2. Add Two Numbers 5行</a></h2></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode, carry=<span class="number">0</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (l1 <span class="keyword">or</span> l2): <span class="keyword">return</span> ListNode(<span class="number">1</span>) <span class="keyword">if</span> carry <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">        l1, l2 = l1 <span class="keyword">or</span> ListNode(<span class="number">0</span>), l2 <span class="keyword">or</span> ListNode(<span class="number">0</span>)</span><br><span class="line">        val = l1.val + l2.val + carry</span><br><span class="line">        l1.val, l1.<span class="built_in">next</span> = val % <span class="number">10</span>, self.addTwoNumbers(l1.<span class="built_in">next</span>, l2.<span class="built_in">next</span>, val &gt; <span class="number">9</span>)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br></pre></td></tr></table></figure>
<ul>
<li>int(True) 等于 1</li>
<li>None or 7 等于 7</li>
<li>用 carry 记录是否应该进位<h2 id="3-Longest-Substring-Without-Repeating-Characters-3行"><a href="#3-Longest-Substring-Without-Repeating-Characters-3行" class="headerlink" title="3. Longest Substring Without Repeating Characters 3行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">3. Longest Substring Without Repeating Characters 3行</a></h2></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        b, m, d = <span class="number">0</span>, <span class="number">0</span>, &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, l <span class="keyword">in</span> <span class="built_in">enumerate</span>(s): b, m, d[l] = <span class="built_in">max</span>(b, d.get(l, -<span class="number">1</span>) + <span class="number">1</span>), <span class="built_in">max</span>(m, i - b), i</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(m, <span class="built_in">len</span>(s) - b)</span><br></pre></td></tr></table></figure>
<ul>
<li>b代表起始位置，m代表上一步的最大无重复子串，d是一个字典，记录着到当前步骤出现过的字符对应的最大位置</li>
<li>每次迭代过程中，遇到遇见过的字符时，b就会变为那个字符上一次出现位置+1，m记录上一次应该达到的全局最大值，所以最后需要再比较一次<h2 id="4-Median-of-Two-Sorted-Arrays-5行"><a href="#4-Median-of-Two-Sorted-Arrays-5行" class="headerlink" title="4. Median of Two Sorted Arrays 5行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/median-of-two-sorted-arrays/">4. Median of Two Sorted Arrays 5行</a></h2></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; float:</span></span><br><span class="line">        a, b, m = *<span class="built_in">sorted</span>((nums1, nums2), key=<span class="built_in">len</span>), (<span class="built_in">len</span>(nums1) + <span class="built_in">len</span>(nums2) - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        self.__class__.__getitem__ = <span class="keyword">lambda</span> self, i: m-i-<span class="number">1</span> &lt; <span class="number">0</span> <span class="keyword">or</span> a[i] &gt;= b[m-i-<span class="number">1</span>]</span><br><span class="line">        i = bisect.bisect_left(self, <span class="literal">True</span>, <span class="number">0</span>, <span class="built_in">len</span>(a))</span><br><span class="line">        r = <span class="built_in">sorted</span>(a[i:i+<span class="number">2</span>] + b[m-i:m-i+<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> (r[<span class="number">0</span>] + r[<span class="number">1</span> - (<span class="built_in">len</span>(a) + <span class="built_in">len</span>(b)) % <span class="number">2</span>]) / <span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>本题思路与官方题解类似，时间复杂度O(log(min(m, n)))，没看过的话建议先大体了解一下</li>
<li>python 中 bisect 模块针对的是 list, 如果直接构造 list，时间复杂度为 O(min(m, n))，因此我们修改当前类的魔法方法伪造 list</li>
<li>在一个有序递增数列中，中位数左边的那部分的最大值一定小于或等于右边部分的最小值</li>
<li>如果总数组长度为奇数，m 代表中位数的索引，否则 m 代表用于计算中位数的那两个数字的左边一个。比如输入为[1,2]，[3]，那么m应该为[1,2,3]中位数2的索引1，如果输入为[1,3]，[2,4]，那么m应该为[1,2,3,4]中2的索引1</li>
<li>使用二分搜索找到 m 对应的值在a或b中对应的索引，也就是说，我们要找的中位数或中位数左部应该是 a[i] 或者 b[m-i]</li>
<li>bisect.bisect_left 搜索列表中保持列表升序的情况下，True应该插入的位置（从左侧），比如 [F,F,T] 返回 2，[F,F] 返回 2</li>
<li>这里保证 a 是 nums1 和 nums2 中较短的那个，是为了防止二分搜索的时候索引越界</li>
<li>sorted返回一个list，假设返回值是 [nums1, nums2]，那么前面加个 * 号就代表取出列表的所有内容，相当于一个迭代器，结果相当于直接写 nums1, nums2<h2 id="5-Longest-Palindromic-Substring-5行"><a href="#5-Longest-Palindromic-Substring-5行" class="headerlink" title="5. Longest Palindromic Substring 5行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring 5行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        r = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> [(i, j) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)) <span class="keyword">for</span> j <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>)]:</span><br><span class="line">            <span class="keyword">while</span> i &gt; -<span class="number">1</span> <span class="keyword">and</span> i + j &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[i] == s[i + j]: i, j = i - <span class="number">1</span>, j + <span class="number">2</span></span><br><span class="line">            r = <span class="built_in">max</span>(r, s[i + <span class="number">1</span>:i + j], key=<span class="built_in">len</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span> <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">else</span> r</span><br></pre></td></tr></table></figure></li>
<li>遍历字符串的每个索引 i，判断能否以 s[i] 或 s[i:i+j+1] 为中心向往拓展回文字符串<h2 id="7-Reverse-Integer-2行"><a href="#7-Reverse-Integer-2行" class="headerlink" title="7. Reverse Integer 2行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-integer/">7. Reverse Integer 2行</a></h2></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        r = x // <span class="built_in">max</span>(<span class="number">1</span>, <span class="built_in">abs</span>(x)) * <span class="built_in">int</span>(<span class="built_in">str</span>(<span class="built_in">abs</span>(x))[::-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> r <span class="keyword">if</span> r.bit_length() &lt; <span class="number">32</span> <span class="keyword">or</span> r == -<span class="number">2</span>**<span class="number">31</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>x // max(1, abs(x))意味着 0：x为0， 1：x为正， -1：x为负，相当于被废弃的函数cmp</li>
<li>[::-1]代表序列反转</li>
<li>2^31 和 -2^31 的比特数为32，其中正负号占用了一位</li>
<li>32位整数范围 [−2^31,  2^31 − 1] 中正数范围小一个是因为0的存在<h2 id="8-String-to-Integer-atoi-1行"><a href="#8-String-to-Integer-atoi-1行" class="headerlink" title="8. String to Integer (atoi) 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/string-to-integer-atoi/">8. String to Integer (atoi) 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">min</span>(<span class="built_in">int</span>(*re.findall(<span class="string">&#x27;^[\+\-]?\d+&#x27;</span>, s.lstrip())), <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>), -<span class="number">2</span>**<span class="number">31</span>)</span><br></pre></td></tr></table></figure></li>
<li>使用正则表达式 <code>^：匹配字符串开头，[\+\-]：代表一个+字符或-字符，?：前面一个字符可有可无，\d：一个数字，+：前面一个字符的一个或多个，\D：一个非数字字符，*：前面一个字符的0个或多个</code></li>
<li><code>max(min(数字, 2**31 - 1), -2**31)</code> 用来防止结果越界<h2 id="9-Palindrome-Number-1行"><a href="#9-Palindrome-Number-1行" class="headerlink" title="9. Palindrome Number 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/palindrome-number/">9. Palindrome Number 1行</a></h2></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(x) == <span class="built_in">str</span>(x)[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>不使用字符串的进阶解法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        r = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> i: <span class="built_in">int</span>(<span class="number">10</span>**-i * x % <span class="number">10</span>), <span class="built_in">range</span>(<span class="built_in">int</span>(math.log10(x)), -<span class="number">1</span>, -<span class="number">1</span>))) <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> [<span class="number">0</span>, x]</span><br><span class="line">        <span class="keyword">return</span> r == r[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>思路是一样的，这里把整数转成了列表而不是字符串</li>
<li>比如一个整数12321，我想取出百位数可以这么做：12321 * 10^{int(log_{10}12321)} % 10 = 123 % 10 = 3<h2 id="11-Container-With-Most-Water-3行"><a href="#11-Container-With-Most-Water-3行" class="headerlink" title="11. Container With Most Water 3行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/container-with-most-water/">11. Container With Most Water 3行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span>(<span class="params">self, height: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        res, l, r = <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r: res, l, r = (<span class="built_in">max</span>(res,  height[l] * (r - l)), l + <span class="number">1</span>, r) <span class="keyword">if</span> height[l] &lt; height[r] <span class="keyword">else</span> (<span class="built_in">max</span>(res,  height[r] * (r - l)), l, r - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
<li>双指针 O(N) 解法</li>
<li>res：结果，l：容器左壁索引，r：容器右壁索引</li>
<li>如果 height[l] &lt; height[r] 那么 l += 1 否则 r -= 1，说明：如果 height[0] &lt; height[3] 那么(0, 1), (0, 2)对应的容器体积一定小于(0, 3)的，因为此时计算体积的时候高为 height(0)，容器的宽减少而高不增加，面积必然缩小<h2 id="13-Roman-to-Integer-2行"><a href="#13-Roman-to-Integer-2行" class="headerlink" title="13. Roman to Integer 2行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/roman-to-integer/">13. Roman to Integer 2行</a></h2></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        d = &#123;<span class="string">&#x27;I&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;IV&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;V&#x27;</span>:<span class="number">5</span>, <span class="string">&#x27;IX&#x27;</span>:<span class="number">8</span>, <span class="string">&#x27;X&#x27;</span>:<span class="number">10</span>, <span class="string">&#x27;XL&#x27;</span>:<span class="number">30</span>, <span class="string">&#x27;L&#x27;</span>:<span class="number">50</span>, <span class="string">&#x27;XC&#x27;</span>:<span class="number">80</span>, <span class="string">&#x27;C&#x27;</span>:<span class="number">100</span>, <span class="string">&#x27;CD&#x27;</span>:<span class="number">300</span>, <span class="string">&#x27;D&#x27;</span>:<span class="number">500</span>, <span class="string">&#x27;CM&#x27;</span>:<span class="number">800</span>, <span class="string">&#x27;M&#x27;</span>:<span class="number">1000</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>([d.get(s[<span class="built_in">max</span>(i-<span class="number">1</span>, <span class="number">0</span>):i+<span class="number">1</span>], d[n]) <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(s)])</span><br></pre></td></tr></table></figure>
<ul>
<li>构建一个字典记录所有罗马数字子串，注意长度为2的子串记录的值是（实际值-子串内左边罗马数字代表的数值）</li>
<li>这样一来，遍历整个s的时候判断当前位置和前一个位置的两个字符组成的字符串是否在字典内，如果在就记录值，不在就说明当前位置不存在小数字在前面的情况，直接记录当前位置字符对应值</li>
<li>举个例子，遍历经过IV的时候先记录I的对应值1再往前移动一步记录IV的值3，加起来正好是IV的真实值4。max函数在这里是为了防止遍历第一个字符的时候出现[-1:0]的情况<h2 id="14-Longest-Common-Prefix-2行"><a href="#14-Longest-Common-Prefix-2行" class="headerlink" title="14. Longest Common Prefix 2行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/longest-common-prefix/">14. Longest Common Prefix 2行</a></h2></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span>(<span class="params">self, strs: List[<span class="built_in">str</span>]</span>) -&gt; str:</span></span><br><span class="line">        r = [<span class="built_in">len</span>(<span class="built_in">set</span>(c)) == <span class="number">1</span> <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">zip</span>(*strs)] + [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>][:r.index(<span class="number">0</span>)] <span class="keyword">if</span> strs <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>利用好zip和set<h2 id="15-3Sum-5行"><a href="#15-3Sum-5行" class="headerlink" title="15. 3Sum 5行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum/">15. 3Sum 5行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        nums, r = <span class="built_in">sorted</span>(nums), <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">2</span>) <span class="keyword">if</span> i &lt; <span class="number">1</span> <span class="keyword">or</span> nums[i] &gt; nums[i-<span class="number">1</span>]]:</span><br><span class="line">            d = &#123;-nums[i]-n: j <span class="keyword">for</span> j, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums[i + <span class="number">1</span>:])&#125;</span><br><span class="line">            r.update([(nums[i], n, -nums[i]-n) <span class="keyword">for</span> j, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums[i+<span class="number">1</span>:]) <span class="keyword">if</span> n <span class="keyword">in</span> d <span class="keyword">and</span> d[n] &gt; j])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">list</span>, r))</span><br></pre></td></tr></table></figure></li>
<li>时间复杂度：O(N^2)</li>
<li>这里 sort 一是为了避免重复，这一点可以体现在我们输出的结果都是升序的，如果不这么做 set 无法排除一些相同结果，而是为了节省计算，防止超时</li>
<li>for 循环内部的代码思想同<code> 第一题 Two Sum</code>，用字典记录｛需要的值:当前索引｝，如果字典中存在相同的数字，那么将会记录比较大的那个索引，因此可以用<code>d[n] &gt; i</code>来避免一个元素重复选择</li>
<li><code>(nums[i], n, -nums[i]-n)</code>保证了列表升序<h2 id="16-3Sum-Closest-7行"><a href="#16-3Sum-Closest-7行" class="headerlink" title="16. 3Sum Closest 7行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/3sum-closest/">16. 3Sum Closest 7行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        nums, r, end = <span class="built_in">sorted</span>(nums), <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">2</span>):</span><br><span class="line">            i, j = <span class="built_in">max</span>(c + <span class="number">1</span>, bisect.bisect_left(nums, target - nums[end] - nums[c], c + <span class="number">1</span>, end) - <span class="number">1</span>), end</span><br><span class="line">            <span class="keyword">while</span> r != target <span class="keyword">and</span> i &lt; j:</span><br><span class="line">                s = nums[c] + nums[i] + nums[j]</span><br><span class="line">                r, i, j = <span class="built_in">min</span>(r, s, key=<span class="keyword">lambda</span> x: <span class="built_in">abs</span>(x - target)), i + (s &lt; target), j - (s &gt; target)</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure></li>
<li>float(‘inf’) = 正无穷</li>
<li>排序，遍历，双指针，O(N^2) 时间复杂度，二分法初始化</li>
<li>排序是为了使用双指针，首先遍历得到索引 c，然后计算 c，左指针 i，右指针 j 对应数字之和，如果大于 target，j 向内移动，否则 i 向内移动</li>
<li>i 的初始值不是 c + 1，是为了减少计算量，用二分法得到一个合理的初始值<h2 id="20-Valid-Parentheses-2行"><a href="#20-Valid-Parentheses-2行" class="headerlink" title="20. Valid Parentheses 2行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/valid-parentheses/">20. Valid Parentheses 2行</a></h2></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">any</span>((<span class="string">&#x27;()&#x27;</span> <span class="keyword">in</span> s, <span class="string">&#x27;[]&#x27;</span> <span class="keyword">in</span> s, <span class="string">&#x27;&#123;&#125;&#x27;</span> <span class="keyword">in</span> s)): s = s.replace(<span class="string">&#x27;()&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;[]&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;&#123;&#125;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> s</span><br></pre></td></tr></table></figure>
<ul>
<li><p>不断删除有效括号直到不能删除，思路简单效率低。另外，stack的方法也很简单，而且快多了。</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        stack, d = [], &#123;<span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;(&#x27;</span>: <span class="string">&#x27;)&#x27;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">in</span> <span class="string">&#x27;&#123;[(&#x27;</span>:</span><br><span class="line">                stack += [p];</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> (stack <span class="keyword">and</span> d[stack.pop()] == p):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> stack</span><br></pre></td></tr></table></figure>
<h2 id="21-Merge-Two-Sorted-Lists-4行"><a href="#21-Merge-Two-Sorted-Lists-4行" class="headerlink" title="21. Merge Two Sorted Lists 4行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-two-sorted-lists/">21. Merge Two Sorted Lists 4行</a></h2></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &gt; l2.val: l1, l2 = l2, l1</span><br><span class="line">            l1.<span class="built_in">next</span> = self.mergeTwoLists(l1.<span class="built_in">next</span>, l2)</span><br><span class="line">        <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br></pre></td></tr></table></figure>
<ul>
<li><p>7 or 9 等于 7</p>
</li>
<li><p>None and 7 等于 None</p>
</li>
<li><p>sorted用在这里为了保证 l1 的值小于等于 l2 的值</p>
<h2 id="23-Merge-k-Sorted-Lists-4行"><a href="#23-Merge-k-Sorted-Lists-4行" class="headerlink" title="23. Merge k Sorted Lists 4行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-k-sorted-lists/">23. Merge k Sorted Lists 4行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span>(<span class="params">self, lists: List[ListNode]</span>) -&gt; ListNode:</span></span><br><span class="line">        r, n, p = [], lists <span class="keyword">and</span> lists.pop(), <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> lists <span class="keyword">or</span> n: r[<span class="built_in">len</span>(r):], n = ([n], n.<span class="built_in">next</span> <span class="keyword">or</span> lists <span class="keyword">and</span> lists.pop()) <span class="keyword">if</span> n <span class="keyword">else</span> ([], lists.pop())</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">sorted</span>(r, key=<span class="keyword">lambda</span> x: x.val, reverse=<span class="literal">True</span>): n.<span class="built_in">next</span>, p = p, n</span><br><span class="line">        <span class="keyword">return</span> n <span class="keyword">if</span> r <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure></li>
<li><p>本题思路：</p>
<ol>
<li>把题目给的所有链表中的所有节点放进一个列表 r。</li>
<li>对这个列表 r 中的所有节点进行从大到小的排序。O(NlogN)</li>
<li>把每个节点的指针指向前一个节点。（第一个节点，也就是最大的那个，指向None。）</li>
<li>返回最后一个节点，也就是整个新链表的开头。</li>
</ol>
</li>
<li><p>如何把所有节点放进 r(result link)？</p>
<p>  我们首先初始化 r 为空列表，初始化 n(node) 为题目所给的第一个链表的开头节点，并删除lists中的这个节点，接着进入while循环，如果 n 不为空，那么 r += [n]，这里使用了切片的技巧（r[len(r):]=[n]相当于r=r+[n]），n=n.next，如果n是第一个链表的最后一个节点的话n.next就是None，下一次while的时候如果lists不为空就说明还有别的链表，此时n为None，我们让 r 不变，n=lists.pop()，也就是从lists中再取下一个节点赋值给n，重复以上步骤直到 lists 为空，我们就把所有节点放进 r 了。</p>
</li>
<li><p>怎么对 r 排序？</p>
<p>  用了sorted函数，其中key定义了排序时用来比较的是每个元素的val属性，同时设置reverse为True代表降序排序。</p>
</li>
<li><p>如何修改每个节点的指针？</p>
<p>  我们初始化 p(previous node) 为None。遍历降序排好的列表 r，r中的第一个元素就是值最大的元素，也就是我们应该返回的链表的结尾，我们设置它指向None，然后让p=这个节点，继续for循环。之后每经过一个节点 n 就把这个节点的next属性设置为上一个节点 p，遍历完成之后的 n，也就是我们遍历经过的最后一个元素，拥有最小的值，自然就是整个新链表的起始节点，我们将其作为输出值，函数返回。</p>
</li>
</ul>
<h2 id="26-Remove-Duplicates-from-Sorted-Array-3行"><a href="#26-Remove-Duplicates-from-Sorted-Array-3行" class="headerlink" title="26. Remove Duplicates from Sorted Array 3行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">26. Remove Duplicates from Sorted Array 3行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[i-<span class="number">1</span>]: nums.pop(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure>
<ul>
<li>时间效率O(N)空间效率O(1)，逆遍历可以防止删除某个元素后影响下一步索引的定位。<h2 id="28-Implement-strStr-1行"><a href="#28-Implement-strStr-1行" class="headerlink" title="28. Implement strStr() 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/implement-strstr/">28. Implement strStr() 1行</a></h2></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">		<span class="keyword">return</span> haystack.find(needle)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>不用内置函数也可以</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">strStr</span>(<span class="params">self, haystack: <span class="string">&#x27;str&#x27;</span>, needle: <span class="string">&#x27;str&#x27;</span></span>) -&gt; &#x27;int&#x27;:</span></span><br><span class="line">	    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(haystack) - <span class="built_in">len</span>(needle) + <span class="number">1</span>):</span><br><span class="line">	        <span class="keyword">if</span> haystack[i:i+<span class="built_in">len</span>(needle)] == needle:</span><br><span class="line">	            <span class="keyword">return</span> i</span><br><span class="line">    	<span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="33-Search-in-Rotated-Sorted-Array-3行"><a href="#33-Search-in-Rotated-Sorted-Array-3行" class="headerlink" title="33. Search in Rotated Sorted Array 3行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/search-in-rotated-sorted-array/">33. Search in Rotated Sorted Array 3行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">        self.__class__.__getitem__ = <span class="keyword">lambda</span> self, m: <span class="keyword">not</span>(target &lt; nums[<span class="number">0</span>] &lt;= nums[m] <span class="keyword">or</span> nums[<span class="number">0</span>] &lt;= nums[m] &lt; target <span class="keyword">or</span> nums[m] &lt; target &lt;= nums[-<span class="number">1</span>])</span><br><span class="line">        i = bisect.bisect_left(self, <span class="literal">True</span>, <span class="number">0</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">        <span class="keyword">return</span> i <span class="keyword">if</span> target <span class="keyword">in</span> nums[i:i+<span class="number">1</span>] <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li><p>作出数列的函数图像，可以看作是一个含断点的局部递增函数，形如:zap:，前面一段总是比较高</p>
</li>
<li><p>python 中 bisect 模块针对的是 list, 如果直接构造 list，相当于遍历所有元素，时间复杂度为 O(N) 而不是 O(logN)，因此我们修改当前类的魔法方法伪造 list，然后用当前类代替list</p>
</li>
<li><p>用二分搜索时，m 代表 middle，low 代表 low，hi 代表 high，当满足任一条件｛① targe &lt; middle 且 middle 在前一段上 且 target &lt; nums[0] ② target &gt; middle 且 middle 在第一段上 ③ target &gt; middle 且 middle 在第二段上 且 target &lt;= nums[-1]｝时，应该向右搜索，因此 getitem 返回 False。</p>
</li>
<li><p>另外还有一种简单的思路：二分法找到断点的位置恢复原始数组，然后正常二分法即可</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums, target</span>):</span></span><br><span class="line">	lo, hi, k = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>, -<span class="number">1</span></span><br><span class="line">	<span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">	    m = (lo + hi) // <span class="number">2</span></span><br><span class="line">	    <span class="keyword">if</span> m == <span class="built_in">len</span>(nums) - <span class="number">1</span> <span class="keyword">or</span> nums[m] &gt; nums[m+<span class="number">1</span>]:</span><br><span class="line">		k = m + <span class="number">1</span></span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	    <span class="keyword">elif</span> m == <span class="number">0</span> <span class="keyword">or</span> nums[m] &lt; nums[m-<span class="number">1</span>]:</span><br><span class="line">		k = m</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	    <span class="keyword">if</span> nums[m] &gt; nums[<span class="number">0</span>]:</span><br><span class="line">		lo = m + <span class="number">1</span></span><br><span class="line">	    <span class="keyword">else</span>:</span><br><span class="line">		hi = m - <span class="number">1</span></span><br><span class="line">	i = (bisect.bisect_left(nums[k:] + nums[:k], target) + k) % <span class="built_in">max</span>(<span class="built_in">len</span>(nums), <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">return</span> i <span class="keyword">if</span> nums <span class="keyword">and</span> nums[i] == target <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="38-Count-and-Say-1行"><a href="#38-Count-and-Say-1行" class="headerlink" title="38. Count and Say 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/count-and-say/">38. Count and Say 1行</a></h2></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span> * (n <span class="keyword">is</span> <span class="number">1</span>) <span class="keyword">or</span> re.sub(<span class="string">r&#x27;(.)\1*&#x27;</span>, <span class="keyword">lambda</span> m: <span class="built_in">str</span>(<span class="built_in">len</span>(m.group())) + m.group(<span class="number">1</span>), self.countAndSay(n - <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li><p>正则表达式 re.sub(正则，替换字符串或函数，被替换字符串，是否区分大小写)</p>
</li>
<li><p>. 可匹配任意一个除了\n的字符<br>(.) 匹配任意一个除了\n的字符并把这个匹配结果放进第一组<br>(.)\1 匹配一个任意字符的二次重复并把那个字符放入数组<br>(.)\1* 匹配一个任意字符的多次重复并把那个字符放入数组</p>
</li>
<li><p>group(default=0)可以取匹配文本   group(1)取第一个括号内的文本</p>
<h2 id="43-Multiply-Strings-5行"><a href="#43-Multiply-Strings-5行" class="headerlink" title="43. Multiply Strings 5行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/multiply-strings/">43. Multiply Strings 5行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, n1 <span class="keyword">in</span> <span class="built_in">enumerate</span>(num1[::-<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">for</span> j, n2 <span class="keyword">in</span> <span class="built_in">enumerate</span>(num2[::-<span class="number">1</span>]): d[i + j] = d.get(i + j, <span class="number">0</span>) + <span class="built_in">int</span>(n1) * <span class="built_in">int</span>(n2)</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> [*d]: d[k + <span class="number">1</span>], d[k] = d.get(k + <span class="number">1</span>, <span class="number">0</span>) + <span class="built_in">int</span>(d[k] * <span class="number">0.1</span>), d[k] % <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> re.sub(<span class="string">&#x27;^0*&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, d.values()))[::-<span class="number">1</span>]) <span class="keyword">or</span> <span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>本题的难点在于计算整数的时候不能超过32bits，因此使用竖式计算</p>
</li>
<li><p>我们遍历num1中的每个数字n1，然后带着这个数字遍历num2中的每个数字n2做乘法，所得乘积放进 d 中相应的位置然后逐位计算结果</p>
</li>
<li><p>i + j 正好对应俩个数字相乘后所在的位置，比如 0 + 0 就应该是个位， 0 + 1 就是十位， 1 + 1 百位。这里所说的位置可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/Give_me_the_who/article/details/80313860">这篇博客中的过程图</a></p>
<h2 id="46-Permutations-1行"><a href="#46-Permutations-1行" class="headerlink" title="46. Permutations 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/permutations/">46. Permutations 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">return</span> [[n] + sub <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums) <span class="keyword">for</span> sub <span class="keyword">in</span> self.permute(nums[:i] + nums[i+<span class="number">1</span>:])] <span class="keyword">or</span> [nums]</span><br></pre></td></tr></table></figure></li>
<li><p>每次固定第一个数字递归地排列数组剩余部分</p>
</li>
<li><p>python 有内置函数可以直接实现</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">	<span class="keyword">from</span> itertools <span class="keyword">import</span> permutations</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">list</span>(permutations(nums))</span><br></pre></td></tr></table></figure>
<h2 id="53-Maximum-Subarray-2行"><a href="#53-Maximum-Subarray-2行" class="headerlink" title="53. Maximum Subarray 2行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-subarray/">53. Maximum Subarray 2行</a></h2></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> r, x: (<span class="built_in">max</span>(r[<span class="number">0</span>], r[<span class="number">1</span>]+x), <span class="built_in">max</span>(r[<span class="number">1</span>]+x,x)), nums, (<span class="built_in">max</span>(nums), <span class="number">0</span>))[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/XXCXY/p/5180245.html">reduce 函数详解</a></p>
</li>
<li><p>r[0]代表以当前位置为结尾的局部最优解</p>
</li>
<li><p>r[1]代表全局最优解</p>
</li>
<li><p>直接DP的解法更好理解一些</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] = <span class="built_in">max</span>(nums[i], nums[i] + nums[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br></pre></td></tr></table></figure>
<h2 id="54-Spiral-Matrix-1行"><a href="#54-Spiral-Matrix-1行" class="headerlink" title="54. Spiral Matrix 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/spiral-matrix/">54. Spiral Matrix 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">return</span> matrix <span class="keyword">and</span> [*matrix.pop(<span class="number">0</span>)] + self.spiralOrder([*<span class="built_in">zip</span>(*matrix)][::-<span class="number">1</span>])</span><br></pre></td></tr></table></figure></li>
<li><p>为什么是<code>[*matrix.pop(0)]</code>而不是<code>matrix.pop(0)</code>？因为对于后面的递归，传进来的列表中元素是tuple</p>
<h2 id="58-Length-of-Last-Word-1行"><a href="#58-Length-of-Last-Word-1行" class="headerlink" title="58. Length of Last Word 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/length-of-last-word/">58. Length of Last Word 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s.strip(<span class="string">&#x27; &#x27;</span>).split(<span class="string">&#x27; &#x27;</span>)[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h2 id="59-Spiral-Matrix-II-3行"><a href="#59-Spiral-Matrix-II-3行" class="headerlink" title="59. Spiral Matrix II 3行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/spiral-matrix-ii/">59. Spiral Matrix II 3行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[List[int]]:</span></span><br><span class="line">        r, n = [[n**<span class="number">2</span>]], n**<span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">1</span>: n, r = n - <span class="built_in">len</span>(r), [[*<span class="built_in">range</span>(n - <span class="built_in">len</span>(r), n)]] + [*<span class="built_in">zip</span>(*r[::-<span class="number">1</span>])]</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure></li>
<li><p>流程图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">||  &#x3D;&gt;  |9|  &#x3D;&gt;  |8|      |6 7|      |4 5|      |1 2 3|</span><br><span class="line">		 |9|  &#x3D;&gt;  |9 8|  &#x3D;&gt;  |9 6|  &#x3D;&gt;  |8 9 4|</span><br><span class="line">				     |8 7|      |7 6 5|</span><br></pre></td></tr></table></figure>
<h2 id="61-Rotate-List-4行"><a href="#61-Rotate-List-4行" class="headerlink" title="61. Rotate List 4行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/rotate-list/">61. Rotate List 4行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span></span><br><span class="line">        l = []</span><br><span class="line">        <span class="keyword">while</span> head: l[<span class="built_in">len</span>(l):], head = [head], head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> l: l[-<span class="number">1</span>].<span class="built_in">next</span>, l[-<span class="number">1</span> - k % <span class="built_in">len</span>(l)].<span class="built_in">next</span> = l[<span class="number">0</span>], <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> l[- k % <span class="built_in">len</span>(l)] <span class="keyword">if</span> l <span class="keyword">else</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h2 id="62-Unique-Paths-1行"><a href="#62-Unique-Paths-1行" class="headerlink" title="62. Unique Paths 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/unique-paths/">62. Unique Paths 1行</a></h2></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(math.factorial(m+n-<span class="number">2</span>)/math.factorial(m-<span class="number">1</span>)/math.factorial(n-<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>题目可以转换为排列组合问题，解是C(min(m,n), m+n)，从m+n个中选出m个下移或n个右移。</li>
<li>用DP做也很快，以后自己算 C(a, b) 也可以用算这题的DP法代替</li>
<li>math.factorial 的速度不亚于DP，可能内部有优化</li>
<li>0的阶乘为1<h2 id="66-Plus-One-1行"><a href="#66-Plus-One-1行" class="headerlink" title="66. Plus One 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/plus-one/">66. Plus One 1行</a></h2></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span>(<span class="params">self, digits: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">str</span>(<span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, digits))) + <span class="number">1</span>)))</span><br></pre></td></tr></table></figure>
<h2 id="69-Sqrt-x-1行"><a href="#69-Sqrt-x-1行" class="headerlink" title="69. Sqrt(x) 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sqrtx/">69. Sqrt(x) 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(x ** <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<p>出题者应该是希望看到下面的答案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        r = x</span><br><span class="line">        <span class="keyword">while</span> r*r &gt; x:</span><br><span class="line">            r = (r + x/r) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(r)</span><br></pre></td></tr></table></figure>
<ul>
<li>基本不等式(a+b)/2 &gt;=√ab 推导自 (a-b)^2 &gt;= 0，注意 a&gt;0 且 b&gt;0</li>
<li>r 代表 result<h2 id="70-Climbing-Stairs-2行"><a href="#70-Climbing-Stairs-2行" class="headerlink" title="70. Climbing Stairs 2行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/climbing-stairs/">70. Climbing Stairs 2行</a></h2></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> r, _: (r[<span class="number">1</span>], <span class="built_in">sum</span>(r)), <span class="built_in">range</span>(n), (<span class="number">1</span>, <span class="number">1</span>))[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>dp递归方程：到达当前楼梯的路径数 = 到达上个楼梯的路径数 + 到达上上个楼梯的路径数</li>
<li>这里用一个元组 r 来储存（当前楼梯路径数，下一层楼梯路径数）</li>
<li>利用 reduce 来代替for循环。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/XXCXY/p/5180245.html">reduce 函数详解</a><h2 id="78-Subsets-2行"><a href="#78-Subsets-2行" class="headerlink" title="78. Subsets 2行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/subsets/">78. Subsets 2行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>([<span class="built_in">list</span>(combinations(nums, i)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) + <span class="number">1</span>)], [])</span><br></pre></td></tr></table></figure>
<h2 id="88-Merge-Sorted-Array-1行"><a href="#88-Merge-Sorted-Array-1行" class="headerlink" title="88. Merge Sorted Array 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/merge-sorted-array/">88. Merge Sorted Array 1行</a></h2></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: List[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>: nums1[m+n-<span class="number">1</span>], m, n = (nums1[m-<span class="number">1</span>], m-<span class="number">1</span>, n) <span class="keyword">if</span> m <span class="keyword">and</span> nums1[m-<span class="number">1</span>] &gt; nums2[n-<span class="number">1</span>] <span class="keyword">else</span> (nums2[n-<span class="number">1</span>], m, n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>这种题倒着算更容易</p>
</li>
<li><p>上面那行代码其实就相当于：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], m: <span class="built_in">int</span>, nums2: List[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> m <span class="keyword">and</span> nums1[m-<span class="number">1</span>] &gt; nums2[n-<span class="number">1</span>]:</span><br><span class="line">                nums1[m+n-<span class="number">1</span>], m, n = nums1[m-<span class="number">1</span>], m-<span class="number">1</span>, n</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[m+n-<span class="number">1</span>], m, n = nums2[n - <span class="number">1</span>], m, n-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="89-Gray-Code-1行"><a href="#89-Gray-Code-1行" class="headerlink" title="89. Gray Code 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/gray-code/">89. Gray Code 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">lambda</span> r: r + [x | <span class="number">1</span>&lt;&lt;n-<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> r[::-<span class="number">1</span>]])(self.grayCode(n-<span class="number">1</span>)) <span class="keyword">if</span> n <span class="keyword">else</span> [<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>前4个结果：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0]</span><br><span class="line">[0 1]</span><br><span class="line">[00 01 11 10]</span><br><span class="line">[000 001 011 010 110 111 101 100]</span><br></pre></td></tr></table></figure></li>
<li><p>递归方程：这一步结果 = 上一步结果 + 上一步结果的镜像并在每个二进制数字前面加一位1</p>
</li>
<li><p>&lt;&lt; 左移符号，即在二进制表示后加一位 0 ，例子：3&lt;&lt;1 等于 6<code>（011 → 110）</code>，相当于 3 * 2的1次方</p>
</li>
<li><p>x | 1&lt;&lt;n-1 就是在十进制数字 x 的二进制前面加一位1之后的十进制结果，比如 x = 1，有 1 | 10 等于 110</p>
</li>
<li><p>循环可以避免一些不必要的操作，会比递归快一些：</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">	r = [<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">	    r.extend([x | <span class="number">1</span>&lt;&lt;i <span class="keyword">for</span> x <span class="keyword">in</span> r[::-<span class="number">1</span>]])</span><br><span class="line">	<span class="keyword">return</span> r</span><br></pre></td></tr></table></figure></li>
<li><p>或者直接背格雷码的公式🥶吧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">return</span> [i ^ i &gt;&gt; <span class="number">1</span>  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span> &lt;&lt; n)]</span><br></pre></td></tr></table></figure>
<h2 id="94-Binary-Tree-Inorder-Traversal-2行"><a href="#94-Binary-Tree-Inorder-Traversal-2行" class="headerlink" title="94. Binary Tree Inorder Traversal 2行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-inorder-traversal/">94. Binary Tree Inorder Traversal 2行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        f = self.inorderTraversal</span><br><span class="line">        <span class="keyword">return</span> f(root.left) + [root.val] + f(root.right) <span class="keyword">if</span> root <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure></li>
<li><p>递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; List[int]:</span></span><br><span class="line">        r, stack = [], []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                <span class="keyword">return</span> r</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            r.append(node.val)</span><br><span class="line">            root = node.right</span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure></li>
<li><p>迭代</p>
<h2 id="104-Maximum-Depth-of-Binary-Tree-1行"><a href="#104-Maximum-Depth-of-Binary-Tree-1行" class="headerlink" title="104. Maximum Depth of Binary Tree 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">map</span>(self.maxDepth,(root.left, root.right))) + <span class="number">1</span> <span class="keyword">if</span> root <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>利用map函数递归左右节点获取最大值，map函数会将参数一所指向的函数应用于参数二里的所有对象并返回所有结果构成的迭代器</p>
<h2 id="121-Best-Time-to-Buy-and-Sell-Stock-2行"><a href="#121-Best-Time-to-Buy-and-Sell-Stock-2行" class="headerlink" title="121. Best Time to Buy and Sell Stock 2行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">121. Best Time to Buy and Sell Stock 2行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> r, p: (<span class="built_in">max</span>(r[<span class="number">0</span>], p-r[<span class="number">1</span>]), <span class="built_in">min</span>(r[<span class="number">1</span>], p)), prices, (<span class="number">0</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)))[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>r = (结果，之前遍历过的所有元素中的最小值)</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/XXCXY/p/5180245.html">reduce 函数详解</a></p>
<h2 id="122-Best-Time-to-Buy-and-Sell-Stock-II-2行"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II-2行" class="headerlink" title="122. Best Time to Buy and Sell Stock II 2行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/">122. Best Time to Buy and Sell Stock II 2行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(b - a <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(prices, prices[<span class="number">1</span>:]) <span class="keyword">if</span> b &gt; a)</span><br></pre></td></tr></table></figure></li>
<li><p>本题可以在同一天买入和卖出，因此只要当天票价比昨天的高就可以卖出</p>
<h2 id="124-Binary-Tree-Maximum-Path-Sum-4行"><a href="#124-Binary-Tree-Maximum-Path-Sum-4行" class="headerlink" title="124. Binary Tree Maximum Path Sum 4行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/binary-tree-maximum-path-sum/">124. Binary Tree Maximum Path Sum 4行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span>(<span class="params">self, root: TreeNode, ok=<span class="literal">True</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l, r = self.maxPathSum(root.left, <span class="literal">False</span>), self.maxPathSum(root.right, <span class="literal">False</span>)</span><br><span class="line">        self.<span class="built_in">max</span> = <span class="built_in">max</span>(<span class="built_in">getattr</span>(self, <span class="string">&#x27;max&#x27;</span>, <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)), l + root.val + r)</span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">max</span> <span class="keyword">if</span> ok <span class="keyword">else</span> <span class="built_in">max</span>(root.val + <span class="built_in">max</span>(l, r), <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>使用 self.max 记录全局最大值，getattr 返回自身 max 属性的值或预定义的负无穷</p>
</li>
<li><p>本题思路是：递归每一个节点，返回<code>max(以当前节点为结尾的最大路径和,0)</code>。并更新最大值<code>全局最大路径和=max(全局最大路径和，当前节点值+左子树返回结果+右子树返回结果)</code></p>
</li>
<li><p>用ok判断是不是第一次递归，是就返回全局最大值，否则照常</p>
<h2 id="136-Single-Number-2行"><a href="#136-Single-Number-2行" class="headerlink" title="136. Single Number 2行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/single-number/">136. Single Number 2行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="built_in">int</span>.__xor__, nums)</span><br></pre></td></tr></table></figure></li>
<li><p>这里用到了异或（xor），相同的数字异或后为0，0异或任何数都等于那个数，用reduce在列表所有元素之间使用异或^，那么留下的就是那个单独的数字了。</p>
<h2 id="141-Linked-List-Cycle-2行"><a href="#141-Linked-List-Cycle-2行" class="headerlink" title="141. Linked List Cycle 2行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-cycle/">141. Linked List Cycle 2行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">and</span> head.val != <span class="literal">None</span>: head.val, head = <span class="literal">None</span>, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head != <span class="literal">None</span></span><br></pre></td></tr></table></figure></li>
<li><p>这题不支持python3，所以用pyhton2解法代替，下题记得调回来 :baby_chick:</p>
</li>
<li><p>破坏走过的所有节点，下次再遇到就知道了</p>
</li>
<li><p>不过以上方法会丢失原有信息，一般解法为快慢指针</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h2 id="142-Linked-List-Cycle-II-5行"><a href="#142-Linked-List-Cycle-II-5行" class="headerlink" title="142. Linked List Cycle II 5行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/linked-list-cycle-ii/">142. Linked List Cycle II 5行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        s = &#123;<span class="literal">None</span>&#125;</span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">            s.add(head)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></li>
<li><p>把见过的节点丢集合里，下次再遇见就是环的开始</p>
</li>
<li><p>还有一个纯数学的快慢指针解法，设环的起始节点为 E，快慢指针从 head 出发，快指针速度为 2，设相交节点为 X，head 到 E 的距离为 H，E 到 X 的距离为 D，环的长度为 L，那么有：快指针走过的距离等于慢指针走过的距离加快指针多走的距离（多走了 n 圈的 L） <code>2(H + D) = H + D + nL</code>，因此可以推出 <code>H = nL - D</code>，这意味着如果我们让俩个慢指针一个从 head 出发，一个从 X 出发的话，他们一定会在节点 E 相遇</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	  _____</span><br><span class="line">	 &#x2F;     \</span><br><span class="line">head___________E       \</span><br><span class="line">	\       &#x2F;</span><br><span class="line">	 X_____&#x2F; </span><br></pre></td></tr></table></figure>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">	slow = fast = head</span><br><span class="line">	<span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">	    fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">	    slow = slow.<span class="built_in">next</span></span><br><span class="line">	    <span class="keyword">if</span> slow == fast:</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">	<span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> slow:</span><br><span class="line">	    head = head.<span class="built_in">next</span></span><br><span class="line">	    slow = slow.<span class="built_in">next</span></span><br><span class="line">	<span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<h2 id="146-LRU-Cache-7行"><a href="#146-LRU-Cache-7行" class="headerlink" title="146. LRU Cache 7行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lru-cache/">146. LRU Cache 7行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        self.od, self.cap = collections.OrderedDict(), capacity</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.od: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        self.od.move_to_end(key)</span><br><span class="line">        <span class="keyword">return</span> self.od[key]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.od: <span class="keyword">del</span> self.od[key]</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(self.od) == self.cap: self.od.popitem(<span class="literal">False</span>)</span><br><span class="line">        self.od[key] = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = LRUCache(capacity)</span></span><br><span class="line"><span class="comment"># param_1 = obj.get(key)</span></span><br><span class="line"><span class="comment"># obj.put(key,value)</span></span><br></pre></td></tr></table></figure>
<h2 id="148-Sort-List-10行"><a href="#148-Sort-List-10行" class="headerlink" title="148. Sort List 10行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/sort-list/">148. Sort List 10行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (head <span class="keyword">and</span> head.<span class="built_in">next</span>): <span class="keyword">return</span> head</span><br><span class="line">        pre, slow, fast = <span class="literal">None</span>, head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>: pre, slow, fast = slow, slow.<span class="built_in">next</span>, fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        pre.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> self.mergeTwoLists(*<span class="built_in">map</span>(self.sortList, (head, slow)))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &gt; l2.val: l1, l2 = l2, l1</span><br><span class="line">            l1.<span class="built_in">next</span> = self.mergeTwoLists(l1.<span class="built_in">next</span>, l2)</span><br><span class="line">        <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br></pre></td></tr></table></figure></li>
<li><p>使用快慢指针寻找链表中点，并分解链表</p>
</li>
<li><p>递归融合俩个有序链表，详解见 21 题</p>
</li>
<li><p>此处忽略了递归开栈导致的非 常数级空间复杂度（想太多了吧:laughing:），如果一定要抬杠，推荐使用quicksort</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	:type head: ListNode</span></span><br><span class="line"><span class="string">	:rtype: ListNode</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">start, end</span>):</span></span><br><span class="line">	    node = start.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">	    pivotPrev = start.<span class="built_in">next</span></span><br><span class="line">	    pivotPrev.<span class="built_in">next</span> = end</span><br><span class="line">	    pivotPost = pivotPrev</span><br><span class="line">	    <span class="keyword">while</span> node != end:</span><br><span class="line">		temp = node.<span class="built_in">next</span></span><br><span class="line">		<span class="keyword">if</span> node.val &gt; pivotPrev.val:</span><br><span class="line">		    node.<span class="built_in">next</span> = pivotPost.<span class="built_in">next</span></span><br><span class="line">		    pivotPost.<span class="built_in">next</span> = node</span><br><span class="line">		<span class="keyword">elif</span> node.val &lt; pivotPrev.val:</span><br><span class="line">		    node.<span class="built_in">next</span> = start.<span class="built_in">next</span></span><br><span class="line">		    start.<span class="built_in">next</span> = node</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">		    node.<span class="built_in">next</span> = pivotPost.<span class="built_in">next</span></span><br><span class="line">		    pivotPost.<span class="built_in">next</span> = node</span><br><span class="line">		    pivotPost = pivotPost.<span class="built_in">next</span></span><br><span class="line">		node = temp</span><br><span class="line">	    <span class="keyword">return</span> [pivotPrev, pivotPost]</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">quicksort</span>(<span class="params">start, end</span>):</span></span><br><span class="line">	    <span class="keyword">if</span> start.<span class="built_in">next</span> != end:</span><br><span class="line">		prev, post = partition(start, end)</span><br><span class="line">		quicksort(start, prev)</span><br><span class="line">		quicksort(post, end)</span><br><span class="line"></span><br><span class="line">	newHead = ListNode(<span class="number">0</span>)</span><br><span class="line">	newHead.<span class="built_in">next</span> = head</span><br><span class="line">	quicksort(newHead, <span class="literal">None</span>)</span><br><span class="line">	<span class="keyword">return</span> newHead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h2 id="155-Min-Stack-每个1行"><a href="#155-Min-Stack-每个1行" class="headerlink" title="155. Min Stack 每个1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/min-stack/">155. Min Stack 每个1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.data = [(<span class="literal">None</span>, <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>))]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="string">&#x27;int&#x27;</span></span>) -&gt; &#x27;<span class="keyword">None</span>&#x27;:</span></span><br><span class="line">        self.data.append((x, <span class="built_in">min</span>(x, self.data[-<span class="number">1</span>][<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; &#x27;<span class="keyword">None</span>&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.data) &gt; <span class="number">1</span>: self.data.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; &#x27;int&#x27;:</span></span><br><span class="line">        <span class="keyword">return</span> self.data[-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span>(<span class="params">self</span>) -&gt; &#x27;int&#x27;:</span></span><br><span class="line">        <span class="keyword">return</span> self.data[-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.getMin()</span></span><br></pre></td></tr></table></figure>
<h2 id="160-Intersection-of-Two-Linked-Lists-3行"><a href="#160-Intersection-of-Two-Linked-Lists-3行" class="headerlink" title="160. Intersection of Two Linked Lists 3行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/intersection-of-two-linked-lists/">160. Intersection of Two Linked Lists 3行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA, headB</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        a, b = (headA, headB) <span class="keyword">if</span> headA <span class="keyword">and</span> headB <span class="keyword">else</span> (<span class="literal">None</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">while</span> a != b: a, b = <span class="keyword">not</span> a <span class="keyword">and</span> headB <span class="keyword">or</span> a.<span class="built_in">next</span>, <span class="keyword">not</span> b <span class="keyword">and</span> headA <span class="keyword">or</span> b.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure></li>
<li><p>这题不支持 Python3 所以只能用 Python2 做了</p>
</li>
<li><p>把第一条链表的尾部接到第二条链表的开头，第二条接到第一条的开头，就能消除俩条链表的长度差，并在某一时刻在第一个交叉点相遇，或在走完俩条链表长度的时候同时为 None</p>
<h2 id="169-Majority-Element-1行"><a href="#169-Majority-Element-1行" class="headerlink" title="169. Majority Element 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/majority-element/">169. Majority Element 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(nums)[<span class="built_in">len</span>(nums) // <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h2 id="198-House-Robber-2行"><a href="#198-House-Robber-2行" class="headerlink" title="198. House Robber 2行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/house-robber/">198. House Robber 2行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> r, n: (<span class="built_in">max</span>(r[<span class="number">0</span>], n + r[<span class="number">1</span>]), r[<span class="number">0</span>]), nums, (<span class="number">0</span>, <span class="number">0</span>))[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>DP递归方程：一直偷到这家的钱 = max（一直偷到上一家的钱，一直偷到上上家的钱 + 这家的钱）😃有点小绕</p>
</li>
<li><p>以上为下面代码的化简版，<a target="_blank" rel="noopener" href="https://www.cnblogs.com/XXCXY/p/5180245.html">reduce 函数详解</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        last, now = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            last, now = now, <span class="built_in">max</span>(last + i, now)</span><br><span class="line">        <span class="keyword">return</span> now</span><br></pre></td></tr></table></figure></li>
<li><p>DP不一定要数组，这里两个变量就够了，空间复杂度为O(1)</p>
<h2 id="206-Reverse-Linked-List-2行"><a href="#206-Reverse-Linked-List-2行" class="headerlink" title="206. Reverse Linked List 2行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/">206. Reverse Linked List 2行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode, tail=<span class="literal">None</span></span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> head: head.<span class="built_in">next</span>, tail, head = tail, head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> self.reverseList(head, tail) <span class="keyword">if</span> head <span class="keyword">else</span> tail</span><br></pre></td></tr></table></figure></li>
<li><p>递归解法</p>
</li>
<li><p>此解法为尾递归，即直接以递归返回值作为结果，一般编译器会做优化，避免多余的函数开栈操作，实现效果相当于迭代</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        p = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head: head.<span class="built_in">next</span>, p, head = p, head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure></li>
<li><p>迭代解法</p>
<h2 id="215-Kth-Largest-Element-in-an-Array-1行"><a href="#215-Kth-Largest-Element-in-an-Array-1行" class="headerlink" title="215. Kth Largest Element in an Array 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-largest-element-in-an-array/">215. Kth Largest Element in an Array 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sorted</span>(nums)[-k]</span><br></pre></td></tr></table></figure></li>
<li><p>O(NlogN)调库</p>
</li>
<li><p>面试官一般不会接受以上答案的，可以参考下面这个2行O(N)的quick-selection，思路借鉴的quick-sort</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">	l, m, r = [x <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x &gt; nums[<span class="number">0</span>]], [x <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x == nums[<span class="number">0</span>]], [x <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x &lt; nums[<span class="number">0</span>]]</span><br><span class="line">	<span class="keyword">return</span> self.findKthLargest(l, k) <span class="keyword">if</span> k &lt;= <span class="built_in">len</span>(l) <span class="keyword">else</span> nums[<span class="number">0</span>] <span class="keyword">if</span> k &lt;= <span class="built_in">len</span>(l) + <span class="built_in">len</span>(m) <span class="keyword">else</span> self.findKthLargest(r, k - <span class="built_in">len</span>(l) - <span class="built_in">len</span>(m))</span><br></pre></td></tr></table></figure>
<h2 id="217-Contains-Duplicate-1行"><a href="#217-Contains-Duplicate-1行" class="headerlink" title="217. Contains Duplicate 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/contains-duplicate/">217. Contains Duplicate 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums) != <span class="built_in">len</span>(<span class="built_in">set</span>(nums))</span><br></pre></td></tr></table></figure>
<h2 id="230-Kth-Smallest-Element-in-a-BST-3行"><a href="#230-Kth-Smallest-Element-in-a-BST-3行" class="headerlink" title="230. Kth Smallest Element in a BST 3行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">230. Kth Smallest Element in a BST 3行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, root, k</span>):</span></span><br><span class="line">        <span class="keyword">from</span> itertools <span class="keyword">import</span> chain, islice</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">gen</span>(<span class="params">x</span>):</span> <span class="keyword">yield</span> <span class="keyword">from</span> chain(gen(x.left), [x.val], gen(x.right)) <span class="keyword">if</span> x <span class="keyword">else</span> ()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span>(islice(gen(root), k - <span class="number">1</span>, k))</span><br></pre></td></tr></table></figure></li>
<li><p>本题利用迭代器骚了一波:grinning:，不太了解的话看这里 <a target="_blank" rel="noopener" href="https://blog.csdn.net/mieleizhi0522/article/details/82142856">yield 推荐阅读博客</a></p>
</li>
<li><p>chain 函数可以组合多个迭代器，islice 函数对迭代器做切片操作</p>
</li>
<li><p>此题常规解法 中序遍历 还是需要了解下的</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span>(<span class="params">self, root, k</span>):</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	:type root: TreeNode</span></span><br><span class="line"><span class="string">	:type k: int</span></span><br><span class="line"><span class="string">	:rtype: int</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	res = []</span><br><span class="line">	self.visitNode(root, res)</span><br><span class="line">	<span class="keyword">return</span> res[k - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visitNode</span>(<span class="params">self, root, res</span>):</span></span><br><span class="line">	<span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">	    <span class="keyword">return</span></span><br><span class="line">	self.visitNode(root.left, res)</span><br><span class="line">	res.append(root.val)</span><br><span class="line">	self.visitNode(root.right, res)</span><br></pre></td></tr></table></figure>
<h2 id="231-2的幂-1行"><a href="#231-2的幂-1行" class="headerlink" title="231. 2的幂 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/power-of-two/">231. 2的幂 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	:type n: int</span></span><br><span class="line"><span class="string">	:rtype: bool</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> n &amp; n - <span class="number">1</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>2 的幂的二进制形式最高位一定是1，其余为0</p>
</li>
<li><p>用常规思路也行</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span>(<span class="params">self, n</span>):</span></span><br><span class="line">	<span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="number">2</span>**<span class="built_in">int</span>(math.log2(n)) == n</span><br></pre></td></tr></table></figure>
<h2 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-2行"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-2行" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree 2行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. Lowest Common Ancestor of a Binary Search Tree 2行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span></span><br><span class="line">        <span class="keyword">while</span> (root.val - p.val) * (root.val - q.val) &gt; <span class="number">0</span>: root = (root.left, root.right)[p.val &gt; root.val]</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></li>
<li><p>最近公共祖先的值一定介于p、q值之间(闭区间)</p>
<h2 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree-2行"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree-2行" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree 2行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. Lowest Common Ancestor of a Binary Tree 2行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        l, r = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x <span class="keyword">and</span> self.lowestCommonAncestor(x, p, q), (root.left, root.right))</span><br><span class="line">        <span class="keyword">return</span> (root <span class="keyword">in</span> (p, q) <span class="keyword">or</span> l <span class="keyword">and</span> r) <span class="keyword">and</span> root <span class="keyword">or</span> l <span class="keyword">or</span> r</span><br></pre></td></tr></table></figure></li>
<li><p>递归全部节点，p 的祖先节点全部返回 p，q 的祖先节点全部返回 q，除非它同时是俩个节点的最近祖先，也就是 p，q 分别位于左右子树，那么返回自身</p>
</li>
<li><p>这思路用在<a target="_blank" rel="noopener" href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235</a>也行</p>
<h2 id="237-Delete-Node-in-a-Linked-List-1行"><a href="#237-Delete-Node-in-a-Linked-List-1行" class="headerlink" title="237. Delete Node in a Linked List 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/delete-node-in-a-linked-list/">237. Delete Node in a Linked List 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node.val, node.<span class="built_in">next</span> = node.<span class="built_in">next</span>.val, node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>node = node.next</code>是不行的，因为这里只是改了函数参数引用的对象，而原来传进来的 node 没有任何改变</p>
</li>
<li><p>详细说明下：如果Python的函数得到的参数是可变对象（比如list，set，这样的，内部属性可以改变的），那么我们实际得到的是这个对象的浅拷贝。比如这个函数刚刚开始的时候题目传进来一个参数node，我们设这个节点为A，那么实际上得到的参数node是一个对于A的一个浅拷贝，你可以想象node是一把钥匙，它可以打开真正的节点A的门，如果我们现在让<code>node = node.next</code>，那么我们只是换了钥匙，变成了打开 A.next 的门的对应的钥匙，因此链表没有被修改， A没有被修改，只是我们手里的钥匙变了。而如果我们直接写<code>node.val, node.next = node.next.val, node.next.next</code>，就相当于我们先用钥匙找到 A 的门，然后修改了 A 的属性，链表发生变化</p>
</li>
<li><p>此题考查python函数的传参形式为“传对象引用”，相当于浅拷贝（对于可变对象来说）</p>
<h2 id="238-Product-of-Array-Except-Self-5行"><a href="#238-Product-of-Array-Except-Self-5行" class="headerlink" title="238. Product of Array Except Self 5行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/product-of-array-except-self/">238. Product of Array Except Self 5行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        res, l, r = [<span class="number">1</span>] * <span class="built_in">len</span>(nums), <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(nums)), <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="built_in">len</span>(nums)))):</span><br><span class="line">            res[i], l = res[i] * l, l * nums[i]</span><br><span class="line">            res[j], r = res[j] * r, r * nums[j]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li>
<li><p>O(N)双指针双向遍历</p>
<h2 id="268-Missing-Number-1行"><a href="#268-Missing-Number-1行" class="headerlink" title="268. Missing Number 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/missing-number/">268. Missing Number 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="built_in">len</span>(nums) * (<span class="built_in">len</span>(nums) + <span class="number">1</span>) / <span class="number">2</span> - <span class="built_in">sum</span>(nums))</span><br></pre></td></tr></table></figure></li>
<li><p>等差数列求和公式</p>
<h2 id="283-Move-Zeroes-1行"><a href="#283-Move-Zeroes-1行" class="headerlink" title="283. Move Zeroes 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/move-zeroes/">283. Move Zeroes 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nums.sort(key=<span class="built_in">bool</span>, reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>sort 时间复杂度为O(NlogN), 直接遍历可以达到 O(N)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x, nums)):</span><br><span class="line">            nums[i] = n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[i] = <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li><p>直接使用 filter 迭代器可以避免交换操作，思路更简单</p>
<h2 id="292-Nim-Game-1行"><a href="#292-Nim-Game-1行" class="headerlink" title="292. Nim Game 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/nim-game/">292. Nim Game 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canWinNim</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(n % <span class="number">4</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>只要轮到你的时候剩余石头数量不是 4 的倍数都是完胜，因为你有办法使得每次轮到对方的时候剩余石头数量都为 4 的倍数</p>
<h2 id="328-Odd-Even-Linked-List-6行"><a href="#328-Odd-Even-Linked-List-6行" class="headerlink" title="328. Odd Even Linked List 6行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/odd-even-linked-list/">328. Odd Even Linked List 6行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oddEvenList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> head</span><br><span class="line">        r, odd, p, head = head, head, head.<span class="built_in">next</span>, head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            odd.<span class="built_in">next</span>, head.<span class="built_in">next</span>, p.<span class="built_in">next</span> = head, odd.<span class="built_in">next</span>, head.<span class="built_in">next</span></span><br><span class="line">            p, odd, head = p.<span class="built_in">next</span>, head, p.<span class="built_in">next</span> <span class="keyword">and</span> p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure></li>
<li><p>odd 记录上一个奇数位节点，p 记录前一个节点</p>
</li>
<li><p>从第3个位置开始循环，每次都把当前节点接到 odd 后面，然后跳到下一个奇数位节点继续循环</p>
<h2 id="344-Reverse-String-1行"><a href="#344-Reverse-String-1行" class="headerlink" title="344. Reverse String 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-string/">344. Reverse String 1行</a></h2></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span>(<span class="params">self, s: List[<span class="built_in">str</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        s.reverse()</span><br></pre></td></tr></table></figure>
<h2 id="412-Fizz-Buzz-1行"><a href="#412-Fizz-Buzz-1行" class="headerlink" title="412. Fizz Buzz 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/fizz-buzz/">412. Fizz Buzz 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fizzBuzz</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;Fizz&#x27;</span> * (<span class="keyword">not</span> i % <span class="number">3</span>) + <span class="string">&#x27;Buzz&#x27;</span> * (<span class="keyword">not</span> i % <span class="number">5</span>) <span class="keyword">or</span> <span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>)]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>7 or 8 = 7</p>
</li>
<li><p>0 or 8 = 8</p>
<h2 id="414-Third-Maximum-Number-3行"><a href="#414-Third-Maximum-Number-3行" class="headerlink" title="414. Third Maximum Number 3行"></a><a href="">414. Third Maximum Number 3行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">thirdMax</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        nums = <span class="built_in">set</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>((<span class="number">2</span>, <span class="number">0</span>)[<span class="built_in">len</span>(nums) &lt; <span class="number">3</span>]): nums.remove(<span class="built_in">max</span>(nums))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br></pre></td></tr></table></figure>
<h2 id="557-Reverse-Words-in-a-String-III-1行"><a href="#557-Reverse-Words-in-a-String-III-1行" class="headerlink" title="557. Reverse Words in a String III 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-words-in-a-string-iii/">557. Reverse Words in a String III 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseWords</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(s.split(<span class="string">&#x27; &#x27;</span>)[::-<span class="number">1</span>])[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h2 id="771-Jewels-and-Stones-1行"><a href="#771-Jewels-and-Stones-1行" class="headerlink" title="771. Jewels and Stones 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/jewels-and-stones/">771. Jewels and Stones 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numJewelsInStones</span>(<span class="params">self, J: <span class="built_in">str</span>, S: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(S.count(i) <span class="keyword">for</span> i <span class="keyword">in</span> J)</span><br></pre></td></tr></table></figure></li>
<li><p>时间复杂度O(N^2)，另附O(N)解法（set内部实现为dict，in操作时间复杂度为O(N)）</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numJewelsInStones</span>(<span class="params">self, J: <span class="built_in">str</span>, S: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">	j = <span class="built_in">set</span>(J)</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sum</span>(s <span class="keyword">in</span> j <span class="keyword">for</span> s <span class="keyword">in</span> S)</span><br></pre></td></tr></table></figure>
<h2 id="938-Range-Sum-of-BST-1行"><a href="#938-Range-Sum-of-BST-1行" class="headerlink" title="938. Range Sum of BST 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/range-sum-of-bst/">938. Range Sum of BST 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rangeSumBST</span>(<span class="params">self, root: TreeNode, L: <span class="built_in">int</span>, R: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> root <span class="keyword">and</span> root.val * (L &lt;= root.val &lt;= R) + self.rangeSumBST(root.left, L, R) + self.rangeSumBST(root.right, L, R) <span class="keyword">or</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="953-Verifying-an-Alien-Dictionary-1行"><a href="#953-Verifying-an-Alien-Dictionary-1行" class="headerlink" title="953. Verifying an Alien Dictionary 1行"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/verifying-an-alien-dictionary/">953. Verifying an Alien Dictionary 1行</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAlienSorted</span>(<span class="params">self, words, order</span>):</span></span><br><span class="line">        <span class="keyword">return</span> words == <span class="built_in">sorted</span>(words, key=<span class="keyword">lambda</span> w: [order.index(x) <span class="keyword">for</span> x <span class="keyword">in</span> w])</span><br></pre></td></tr></table></figure></li>
<li><p>充分利用 python 序列比较的特点，sorted 的参数 key 可传入一个函数，sorted 函数会将每个元素作为输入，输入到 key 函数并获得返回值，整个序列将按此值的大小来排序。此处 key 函数为<code>lambda w: [order.index(x) for x in w]</code>，其为words中每个单词 word 返回一个 list，list 中每个元素为单词中字母 x 在 order 中的索引。比如当 order 为 ‘abcde……’ 时，单词 ‘cab’ 将返回 [3, 2, 1]。关于俩个 list 的大小比较，服从 python 序列比较的特性，请参考官方文档教程 5.8 节内容。</p>
</li>
<li><p>另外一个通用的方法是简单的数学计算，给每个单词赋予一个数字然后排序对比和原来的数组是否一致即可，每个字母的价值按字母表顺序，第几个就代表几，每进一位需要<code>*10^-2</code>避免冲突，比如字母表是<code>abcde……</code>，单词 cab 的价值就是 <code>3 * 1 + 1 * 0.01 + 2 * 0.0001</code>，价值越小的单词位置应该越靠前</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAlienSorted</span>(<span class="params">self, words: List[<span class="built_in">str</span>], order: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">	d = &#123;c: i + <span class="number">1</span> <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(order)&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sorted</span>(words, key=<span class="keyword">lambda</span> x: <span class="built_in">sum</span>(d[c] * <span class="number">10</span>**(-<span class="number">2</span> * i) <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(x))) == words</span><br></pre></td></tr></table></figure>
<h1 id="专题"><a href="#专题" class="headerlink" title="专题"></a>专题</h1></li>
<li><p>相比于解析部分追求代码的绝对精简，本专题追求以高可读性呈现各大专题的常规思路。俩部分题目可能重复，但专题部分会有更详细的解析，且可能运用不同解法。为降低学习成本，🛫 每个方向会根据<a target="_blank" rel="noopener" href="https://github.com/cy69855522/Clearest-LeetCode-Cpp-Solutions">C++篇</a>收录少数优选的经典题目，若觉得不够请转<a href="#%E8%A7%A3%E6%9E%90">解析部分</a>，若想更改例题，欢迎 issue 提出您的建议或意见。</p>
</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="238-Product-of-Array-Except-Self-双指针"><a href="#238-Product-of-Array-Except-Self-双指针" class="headerlink" title="238. Product of Array Except Self 双指针"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/product-of-array-except-self/">238. Product of Array Except Self 双指针</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = [<span class="number">1</span>] * n</span><br><span class="line">        </span><br><span class="line">        l = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            res[i] *= l</span><br><span class="line">            l *= nums[i]</span><br><span class="line">        </span><br><span class="line">        r = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            res[j] *= r</span><br><span class="line">            r *= nums[j]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<ul>
<li><p>本题利用双指针，新数组每个位置上的值应该等于数组左边所有数字的乘积 × 数组右边所有数字的乘积</p>
</li>
<li><p>1.初始化一个新的数组res（result），包含n个1</p>
<p>2.初始化变量l（left）代表左边的乘积，从左到右遍历数组，每次都让新数组的值乘以它左边数字的乘积l，然后更新l。此时新数组里的所有数字就代表了nums数组中对应位置左边所有数字的乘积</p>
<p>3.再从右往左做一遍同样的操作，最终<code>res[i] = 1 * nums中i左边所有数字的乘积 * nums中i右边所有数字的乘积</code></p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="1-Two-Sum-字典"><a href="#1-Two-Sum-字典" class="headerlink" title="1. Two Sum 字典"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/two-sum/">1. Two Sum 字典</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">	d = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums): </span><br><span class="line">	    <span class="keyword">if</span> n <span class="keyword">in</span> d: <span class="keyword">return</span> [d[n], i]</span><br><span class="line">	    d[target-n] = i</span><br></pre></td></tr></table></figure></li>
<li><p>建立一个字典，每次遍历过一个值就记录与其匹配的值（设置d[匹配值]=当前索引），今后遇见匹配值即可直接返回结果</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="206-Reverse-Linked-List-迭代遍历"><a href="#206-Reverse-Linked-List-迭代遍历" class="headerlink" title="206. Reverse Linked List 迭代遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/">206. Reverse Linked List 迭代遍历</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        p = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            head.<span class="built_in">next</span>, head, p = p, head.<span class="built_in">next</span>, head</span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure></li>
<li><p>此处利用 python 多重赋值表达式的特性（例：<code>a, b = b, a</code>），python 中多变量同时赋值时，右手边的表达式在任何赋值发生之前就被求值了。右手边的表达式是从左到右被求值的</p>
<h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="268-Missing-Number-等差数列"><a href="#268-Missing-Number-等差数列" class="headerlink" title="268. Missing Number 等差数列"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/missing-number/">268. Missing Number 等差数列</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        s = <span class="built_in">sum</span>(nums)</span><br><span class="line">        n += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> n * (n - <span class="number">1</span>) // <span class="number">2</span> - s</span><br></pre></td></tr></table></figure></li>
<li><p>缺失数字 = 0 加到 n+1 的总和 - 数组中所有数字的总和</p>
</li>
<li><p>计算 0 加到 n+1 的总和，可利用等差数列求和公式，此题可理解为<code>总和 = (元素个数 / 2) * (首尾两数字之和)</code></p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="344-Reverse-String-双指针"><a href="#344-Reverse-String-双指针" class="headerlink" title="344. Reverse String 双指针"></a><a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-string/">344. Reverse String 双指针</a></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseString</span>(<span class="params">self, s: List[<span class="built_in">str</span>]</span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            s[i], s[j] = s[j], s[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>腾讯精选50题（Python实现）</p><p><a href="https://huzhiliang.com/2019/05/08/%E8%85%BE%E8%AE%AF%E7%B2%BE%E9%80%8950%E9%A2%98%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89/">https://huzhiliang.com/2019/05/08/%E8%85%BE%E8%AE%AF%E7%B2%BE%E9%80%8950%E9%A2%98%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>ฅ´ω`ฅ</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2019-05-08</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2019-10-31</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Tencent/">Tencent</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="patreon"><span class="icon is-small"><i class="fab fa-patreon"></i></span><span>Patreon</span></a><div class="notification is-danger">You forgot to set the <code>business</code> or <code>currency_code</code> for Paypal. Please set it in <code>_config.yml</code>.</div><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a></div></div></div><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/05/13/LeetCode%E4%B8%8A%E6%9C%80%E9%9A%BE%E7%9A%84%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%E9%A2%98%E6%B2%A1%E6%9C%89%E4%B9%8B%E4%B8%80/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">LeetCode 上最难的链表算法题，没有之一！</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/05/03/permutation_index/"><span class="level-item">Permutation Index</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Your name"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Your name</p><p class="is-size-6 is-block">Your title</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">161</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">14</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">97</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener" id="widget-follow">微博 Weibo</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div><a class="link-more button is-light is-small size-small" href="/friends/">查看更多</a></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Golang/"><span class="level-start"><span class="level-item">Golang</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Kaggle/"><span class="level-start"><span class="level-item">Kaggle</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">85</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">26</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">深度学习</span></span><span class="level-end"><span class="level-item tag">29</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/CNN/"><span class="level-start"><span class="level-item">CNN</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP/"><span class="level-start"><span class="level-item">NLP</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">迁移学习</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E7%A0%B4%E8%A7%A3/"><span class="level-start"><span class="level-item">破解</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">英语学习</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-03-05T05:41:28.000Z">2020-03-05</time></p><p class="title"><a href="/2020/03/05/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BACRF-%E4%B8%89-%E6%A8%A1%E5%9E%8B%E5%AD%A6%E4%B9%A0%E4%B8%8E%E7%BB%B4%E7%89%B9%E6%AF%94%E7%AE%97%E6%B3%95%E8%A7%A3%E7%A0%81/">条件随机场CRF(三) 模型学习与维特比算法解码</a></p><p class="categories"><a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a> / <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP/">NLP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-03-04T08:24:55.000Z">2020-03-04</time></p><p class="title"><a href="/2020/03/04/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BACRF-%E4%BA%8C-%E5%89%8D%E5%90%91%E5%90%8E%E5%90%91%E7%AE%97%E6%B3%95%E8%AF%84%E4%BC%B0%E6%A0%87%E8%AE%B0%E5%BA%8F%E5%88%97%E6%A6%82%E7%8E%87/">条件随机场CRF(二) 前向后向算法评估标记序列概率</a></p><p class="categories"><a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a> / <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP/">NLP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-03-03T02:59:49.000Z">2020-03-03</time></p><p class="title"><a href="/2020/03/03/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BACRF-%E4%B8%80-%E4%BB%8E%E9%9A%8F%E6%9C%BA%E5%9C%BA%E5%88%B0%E7%BA%BF%E6%80%A7%E9%93%BE%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA/">条件随机场CRF(一)从随机场到线性链条件随机场</a></p><p class="categories"><a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a> / <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP/">NLP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-03-02T02:46:01.000Z">2020-03-02</time></p><p class="title"><a href="/2020/03/02/%E6%96%87%E6%9C%AC%E6%8C%96%E6%8E%98%E7%9A%84%E5%88%86%E8%AF%8D%E5%8E%9F%E7%90%86/">文本挖掘的分词原理</a></p><p class="categories"><a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</a> / <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/NLP/">NLP</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-02-20T01:01:00.000Z">2020-02-20</time></p><p class="title"><a href="/2020/02/20/optimize-water-distribution-in-a-village/">optimize water distribution in a village</a></p><p class="categories"><a href="/categories/LeetCode/">LeetCode</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2020/03/"><span class="level-start"><span class="level-item">三月 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/01/"><span class="level-start"><span class="level-item">一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/10/"><span class="level-start"><span class="level-item">十月 2019</span></span><span class="level-end"><span class="level-item tag">33</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/04/"><span class="level-start"><span class="level-item">四月 2019</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/01/"><span class="level-start"><span class="level-item">一月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">十二月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/11/"><span class="level-start"><span class="level-item">十一月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/10/"><span class="level-start"><span class="level-item">十月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/09/"><span class="level-start"><span class="level-item">九月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/07/"><span class="level-start"><span class="level-item">七月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/06/"><span class="level-start"><span class="level-item">六月 2017</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/05/"><span class="level-start"><span class="level-item">五月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/03/"><span class="level-start"><span class="level-item">三月 2017</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/02/"><span class="level-start"><span class="level-item">二月 2017</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/04/"><span class="level-start"><span class="level-item">四月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2015/02/"><span class="level-start"><span class="level-item">二月 2015</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Array/"><span class="tag">Array</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Attention/"><span class="tag">Attention</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Binary-Tree/"><span class="tag">Binary Tree</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CFG/"><span class="tag">CFG</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CNN/"><span class="tag">CNN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CPU/"><span class="tag">CPU</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CYK/"><span class="tag">CYK</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Caffee/"><span class="tag">Caffee</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/English/"><span class="tag">English</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Facebook/"><span class="tag">Facebook</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GAN/"><span class="tag">GAN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GBDT/"><span class="tag">GBDT</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GPU/"><span class="tag">GPU</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GRN/"><span class="tag">GRN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GloVe/"><span class="tag">GloVe</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Google-apac/"><span class="tag">Google apac</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go%E8%AF%AD%E8%A8%80/"><span class="tag">Go语言</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Greedy/"><span class="tag">Greedy</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HMM/"><span class="tag">HMM</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IBM-Modes/"><span class="tag">IBM Modes</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/KL%E6%95%A3%E5%BA%A6/"><span class="tag">KL散度</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LSTM/"><span class="tag">LSTM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LeetCode/"><span class="tag">LeetCode</span><span class="tag">31</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Lexicalized-PCFG/"><span class="tag">Lexicalized PCFG</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Lexized-PCFG/"><span class="tag">Lexized PCFG</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Log-Linear-Models/"><span class="tag">Log-Linear Models</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Machine-Learning/"><span class="tag">Machine Learning</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PCFG/"><span class="tag">PCFG</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paper/"><span class="tag">Paper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Programmer/"><span class="tag">Programmer</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Pytorch/"><span class="tag">Pytorch</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Queue/"><span class="tag">Queue</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RNN/"><span class="tag">RNN</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Seq2seq/"><span class="tag">Seq2seq</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tagging/"><span class="tag">Tagging</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tencent/"><span class="tag">Tencent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tensorflow/"><span class="tag">Tensorflow</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VIP/"><span class="tag">VIP</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Viterbi/"><span class="tag">Viterbi</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Word-representation/"><span class="tag">Word representation</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/XGBoost/"><span class="tag">XGBoost</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/exhaustive-search/"><span class="tag">exhaustive search</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/github/"><span class="tag">github</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/numpy/"><span class="tag">numpy</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/python/"><span class="tag">python</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spark/"><span class="tag">spark</span><span class="tag">23</span></a></div><div class="control"><a class="tags has-addons" href="/tags/turtle/"><span class="tag">turtle</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/word2vec/"><span class="tag">word2vec</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%93%E9%A2%98/"><span class="tag">专题</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/"><span class="tag">二分搜索</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/"><span class="tag">二分搜索树</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%88%86%E6%A0%91/"><span class="tag">二分树</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"><span class="tag">二进制</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"><span class="tag">优化算法</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E7%B1%BB/"><span class="tag">分类</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E8%AF%8D/"><span class="tag">分词</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%91%E6%8C%87offer/"><span class="tag">剑指offer</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E5%9B%9E%E5%BD%92/"><span class="tag">动态回归</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%9E%E5%BD%92/"><span class="tag">回归</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E8%AE%BA/"><span class="tag">图论</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8E%92%E5%BA%8F/"><span class="tag">排序</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86/"><span class="tag">数学原理</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"><span class="tag">数据分析</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%A1%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%9C%BA/"><span class="tag">条件随机场</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6/"><span class="tag">极大似然</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A8%A1%E5%9E%8B%E5%8E%8B%E7%BC%A9/"><span class="tag">模型压缩</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A8%A1%E5%9E%8B%E9%83%A8%E7%BD%B2/"><span class="tag">模型部署</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">深度学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%89%88%E6%9D%83/"><span class="tag">版权</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%89%B9%E5%BE%81%E6%8A%BD%E5%8F%96/"><span class="tag">特征抽取</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AC%94%E8%AE%B0/"><span class="tag">笔记</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"><span class="tag">算法原理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6/"><span class="tag">算法复杂度</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"><span class="tag">线性模型</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%84%E5%90%88%E6%A0%91/"><span class="tag">组合树</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%8F%E5%85%B8%E7%BD%91%E7%BB%9C/"><span class="tag">经典网络</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/"><span class="tag">统计机器翻译</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90/"><span class="tag">网易云音乐</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%81%9A%E7%B1%BB/"><span class="tag">聚类</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"><span class="tag">背包问题</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%84%9A%E6%9C%AC/"><span class="tag">脚本</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%AD%E6%B3%95/"><span class="tag">语法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"><span class="tag">语言模型</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B6%85%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/"><span class="tag">超参数调整</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%81%E7%A7%BB%E5%AD%A6%E4%B9%A0/"><span class="tag">迁移学习</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%92%E5%BD%92/"><span class="tag">递归</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%82%AE%E4%BB%B6/"><span class="tag">邮件</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%93%BE%E8%A1%A8/"><span class="tag">链表</span><span class="tag">19</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%99%8D%E7%BB%B4/"><span class="tag">降维</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95%E4%B8%93%E5%9C%BA/"><span class="tag">面试专场</span><span class="tag">2</span></a></div></div></div></div></div><div class="card widget" id="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/" alt="MCFON" height="28"><img class="logo-img-dark" src="/" alt="MCFON" height="28"></a><p class="is-size-7"><span>&copy; 2020 ฅ´ω`ฅ</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/imaegoo/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><a href="http://www.miitbeian.gov.cn" target="_blank">豫ICP备18017229号</a> - </p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><div class="searchbox-pinyin"><label class="checkbox"><input id="search-by-pinyin" type="checkbox" checked="checked"><span> 拼音检索</span></label></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/imaegoo/pinyin.js" defer></script><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script type="text/javascript" src="/js/imaegoo/imaegoo.js"></script><script type="text/javascript" src="/js/imaegoo/universe.js"></script><script type="text/javascript" src="/js/live2d/autoload.js"></script></body></html>